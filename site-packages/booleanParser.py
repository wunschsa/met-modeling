#
# simpleBool.py
#
# Example of defining a boolean logic parser using
# the operatorGrammar helper method in pyparsing.
#
# In this example, parse actions associated with each
# operator expression will "compile" the expression
# into BoolOperand subclass objects, which can then
# later be evaluted for their boolean value.
#
# Copyright 2006, by Paul McGuire
#



from pyparsing import *

class BoolOperand(object):
	def __init__(self,t):
		self.args = t[0][0::2]
	def __str__(self):
		sep = " %s " % self.reprsymbol
		return "(" + sep.join(map(str,self.args)) + ")"
    
class BoolAnd(BoolOperand):
	reprsymbol = '&'
	def __nonzero__(self):
		for a in self.args:
			if isinstance(a,basestring):
				v = eval(a)
			else:
				v = bool(a)
			if not v:
				return False
		return True

class BoolOr(BoolOperand):
	reprsymbol = '|'    
	def __nonzero__(self):
		for a in self.args:
			if isinstance(a,basestring):
				v = eval(a)
			else:
				v = bool(a)
			if v:
				return True
		return False

class BoolNot(BoolOperand):
	def __init__(self,t):
		self.arg = t[0][1]
	def __str__(self):
		return "~" + str(self.arg)
	def __nonzero__(self):
		if isinstance(self.arg,basestring):
			v = eval(self.arg)
		else:
			v = bool(self.arg)
		return not v

#CHANGE: the Word below was changed from 'alphas' so that it would match most gene names...
#Will match any gene name consisting of alphanums plus any of following characters: .+-_
boolOperand = Word( srange("[A-Za-z0-9.-_]") ) | oneOf("True False")
boolExpr = operatorPrecedence( boolOperand,
	[
	("not", 1, opAssoc.RIGHT, BoolNot),
	("or",  2, opAssoc.LEFT,  BoolOr),
	("and", 2, opAssoc.LEFT,  BoolAnd),
	])


#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#this makes regex to identify the genes within the gpr statement (excludes '(' and ')' and whitespace)
import re
geneRE = re.compile(r"""[^(,^),^\s]+""")


#given a list or dictionary of genesToDelete and a gpr, this decides whether boolean gpr statement is true or false...
def decideGPR (genesToDelete, gpr):
	
	#parse the gpr into an 'official' python boolean expression and make a string version of expression...
	res = boolExpr.parseString(gpr)[0]
	stringres = str(res)
	
	#find all the genes in the bool statement, replace each gene by its 'val' (whether it is in genesToDelete)...
	genes = re.findall(geneRE, stringres)
	for g in genes:
		#skip anything in boolean statement that is not a gene...
		if g == '&' or g == '|':
			continue
		#in human model, gene id like '6733' is modified by adding '.1' or '.2' etc., to stand for different transcripts
		#get rid of these if present (i.e., 6733.1 becomes 6733)...	
		if '.' in g:
			lookup_g = g[:g.find('.')]
		else:
			lookup_g = g
		#replace name of gene with its val...default = True, but if in genesToDelete val = False
		if lookup_g in genesToDelete:
			val = 'False'
		else:
			val = 'True'
		stringres = stringres.replace(g, val)
	
	#python throws error for expressions that have too many arguments...
	if len(stringres.split()) > 255:
		print 'Warning: cannot evaluate gpr for ' + rxn + ', too many genes in expression...skipping'
		
	#now get decide whether reaction fires or not by evaluating statement...
	#if missing data, return True (can't tell, therefore, assume it's ON)...
	if '?' in stringres:
		return True
	rxnexpr = eval(stringres)

	#returns True for rxn that can still fire, given genesToDelete...
	#returns False for rxn that will not fire...
	return rxnexpr
	




#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

if __name__ == '__main__':

	test = ["p and not q",
			"not not p",
			"not(p and q)",
			"q or not p and r",
			"q or not (p and r)",
			"p or q or r",
			"p or q or r and False"
			]

	p = True
	q = False
	r = True
	print "p =", p
	print "q =", q
	print "r =", r
	print
	for t in test:
		res = boolExpr.parseString(t)[0]
		print t,'\t', res, '\t', bool(res)
	
	#USAGE OF decideGPR...give gpr and list (or dict) of genesToDelete		
	gpr = 'gene1 or (gene2 and gene3)'
	genesToDelete = ['gene3', 'gene2']
	print gpr, genesToDelete, decideGPR(genesToDelete, gpr)
		

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	