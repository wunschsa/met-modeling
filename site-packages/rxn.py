#script purpose:

import csv
from pyparsing import *

#make grammar for reaction arrow and some literals...
RXNARROW = oneOf( '<==> --> <=>' ) .setResultsName( "arrow" ) 
plus = Literal("+")
colon = Literal( ":" )

#make grammar for metabolites and compartment prefix that may preceed equation (e.g., '[c] : ')...
METNAME = Word( alphanums + '-_' )
COMPARTMENT = Combine( '[' + Word( alphas, max=1 ) + ']' )
MET = Combine( METNAME + ZeroOrMore( COMPARTMENT ) )
COMPARTMENTPREFIX = Optional( (COMPARTMENT + colon.suppress()), default='trans' ).setResultsName("compartment")
MET_COMPARTMENT = MET + COMPARTMENT

#make grammar for coefficients in equation...
point = Literal( "." )
e     = CaselessLiteral( "E" )
fnumber = Combine( Word( "+-"+nums, nums ) + 
				   Optional( point + Optional( Word( nums ) ) ) +
				   Optional( e + Word( "+-"+nums, nums ) ) )
COEF = Optional( fnumber + White().suppress(), default='1' )

#make grammar for two sides of equation...
REACTANTS = ( Group(COEF + MET) + ZeroOrMore( plus.suppress() + Group(COEF + MET) ) ).setResultsName("reactants")
PRODUCTS = ( Group(COEF + MET) + ZeroOrMore( plus.suppress() + Group(COEF + MET) ) ).setResultsName("products")

#final expression for a reaction equation...
RXN = LineStart().suppress() + COMPARTMENTPREFIX + REACTANTS + RXNARROW + PRODUCTS + LineEnd().suppress()

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::Grammar now defined, parse below...

#sample input strings...
sample1 = '[c] : 2 glc-D + atp --> 0.00334 g6_p + adp'
sample2 = 'glc-D[e] + 0.003 h[e] <==> 2 glc_D[c] + 5e-6 h[c]'
sample3 = '26dap-m[e] + atp[c] + h2o[c] --> 26dap-m[c] + adp[c] + h[c] + pi[c]'
bad1 = 'glc-D[c] + atp[c] --> g6p[c] + adp[c]'

#modelReader = csv.DictReader(open('/Users/sethroberts/Desktop/research/cth/current/cth.workingtest16.txt'), delimiter='\t', fieldnames=['id', 'name', 'rev', 'path', 'ec', 'equation'])
#for row in range(1):
#for row in modelReader:
	#parse input string...
	#rxnequation = bad1
	#rxnequation = row['equation']

def parse( rxnequation ):
	
	try:
		parsedrxn = RXN.parseString( rxnequation )

		#for reactions beginning with a compartment prefix, attach compartment to all reactants and products...
		compartment, rs, arrow, ps = parsedrxn["compartment"][0], parsedrxn["reactants"], parsedrxn["arrow"], parsedrxn["products"]
		if compartment == 'trans': compartment = ''
		reactants, products, species = [], [], []
		for coef, reactant in rs:
			#parsedmet = MET_COMPARTMENT.parseString( reactant + compartment )
			assert '[' in reactant + compartment, 'Missing compartment info in "%s"' % reactant + compartment
			reactants.append([coef, reactant + compartment])
			species.append(['-' + coef, reactant + compartment])
		for coef, product in ps:
			#parsedmet = MET_COMPARTMENT.parseString( product + compartment )
			assert '[' in product + compartment, 'Missing compartment info in "%s"' % product + compartment
			products.append([coef, product + compartment])
			species.append(['+' + coef, product + compartment])				
		
		#print rxnequation
		#print arrow, species # reactants, arrow, products
		#print
		return arrow, species

	except ParseException, err:
		#print err.line
		#print " "*(err.column-1) + "^"
		#print err
		return 0


#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



from pyparsing import Word, Optional, OneOrMore, Group, ParseException

import kegg

kcmpd = kegg.compound()

# define some strings to use later, when describing valid lists 
# of characters for chemical symbols and numbers
caps = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
lowers = caps.lower()
digits = "0123456789"

# Version 1
# Define grammar for a chemical formula
# - an element is a Word, beginning with one of the characters in caps,
#   followed by zero or more characters in lowers
# - an integer is a Word composed of digits
# - an elementRef is an element, optionally followed by an integer - if 
#   the integer is omitted, assume the value "1" as a default; these are 
#   enclosed in a Group to make it easier to walk the list of parsed 
#   chemical symbols, each with its associated number of atoms per 
#   molecule
# - a chemicalFormula is just one or more elementRef's
element = Word( caps, lowers )
integer = Word( digits )
elementRef = Group( element + Optional( integer, default="1" ) )
chemicalFormula = OneOrMore( elementRef )

def balance(rxneq):
	#there are a number of reasons this could fail
	if rxneq == '.':
		#fails
		return '.'

	if not rxneq[0] == '[':
		#add phony rxn compartment
		rxneq = '[c] : ' + rxneq
	
	try:
		arrow, species = parse(rxneq)
	except:
		#fails
		return '.'
		
	counts = {'left':{}, 'right':{}}
	for coef, s in species:
		if float(coef) < 0: side = 'left'
		elif float(coef) > 0: side = 'right'
		formula = '.'
		if s[:-3] in kcmpd.DB:
			formula = kcmpd.DB[s[:-3]].get('FORMULA', '.')

		if formula == '.':
			#fails
			return '.'

		try:
			formulaData = chemicalFormula.parseString(formula)
		except:
			#fails
			return '.'

		for atom,ct in formulaData:
			if not atom in counts[side]:
				counts[side][atom] = 0
			counts[side][atom] += float(coef) * float(ct)

	balancedict = {}
	for atom in counts['left']:
		balancedict[atom] = counts['left'][atom] + counts['right'].get(atom, 0)
	for atom in counts['right']:
		if not atom in balancedict:
			balancedict[atom] = counts['right'][atom]
	balstr = ''
	for atom in balancedict:
		count = str(balancedict[atom])
		if count[-2:] == '.0':
			count = count[:-2]
		balstr = balstr + atom + '=' + count + ','
	balstr = balstr[:-1]
	return balstr
	
