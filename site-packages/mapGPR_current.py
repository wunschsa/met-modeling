#
# simpleBool.py
#
# Example of defining a boolean logic parser using
# the operatorGrammar helper method in pyparsing.
#
# In this example, parse actions associated with each
# operator expression will "compile" the expression
# into BoolOperand subclass objects, which can then
# later be evaluated for their boolean value.
#
# Copyright 2006, by Paul McGuire
#

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Seth added some changes where indicated
# Boolean expressions must be mapped to max/min expressions, see PMID: 18711341

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



from pyparsing import *


class BoolOperand(object):
	def __init__(self,t):
		self.args = t[0][0::2]

	def __str__(self):
		#CHANGE: separators are now all ',' instead of '|' or '&'
		#sep = " %s " % self.reprsymbol
		sep = ", "
		#CHANGE: pref is either 'max' or 'min' for the case of an expression with 'or' or 'and'
		pref = "%s" % self.prefsymbol
		#CHANGE: end result is returning, not expression like '(a & (b | c))', but now 'min(a, max(b, c))'
		return pref + "(" + sep.join(map(str,self.args)) + ")"
    
class BoolAnd(BoolOperand):
	reprsymbol = '&'
	#CHANGE: added variable prefsymbol, which for 'and' is 'min'
	prefsymbol = 'min'
	def __nonzero__(self):
		for a in self.args:
			if isinstance(a,basestring):
				v = eval(a)
			else:
				v = bool(a)
			if not v:
				return False
		return True

class BoolOr(BoolOperand):
	reprsymbol = '|'
	#CHANGE: added variable prefsymbol, which for 'or' is 'max'
	prefsymbol = 'max'
	def __nonzero__(self):
		for a in self.args:
			if isinstance(a,basestring):
				v = eval(a)
			else:
				v = bool(a)
			if v:
				return True
		return False

class BoolNot(BoolOperand):
	def __init__(self,t):
		self.arg = t[0][1]
	def __str__(self):
		return "~" + str(self.arg)
	def __nonzero__(self):
		if isinstance(self.arg,basestring):
			v = eval(self.arg)
		else:
			v = bool(self.arg)
		return not v

#CHANGE: the Word below was changed from 'alphas' so that it would match most gene names...
#Will match any gene name consisting of alphanums plus any of following characters: :.+-_
boolOperand = Word( srange("[A-Za-z0-9.:-_]") ) | oneOf("True False")
boolExpr = operatorPrecedence( boolOperand,
	[
	("not", 1, opAssoc.RIGHT, BoolNot),
	("and", 2, opAssoc.LEFT,  BoolAnd),
	("or",  2, opAssoc.LEFT,  BoolOr),
	])

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::

"""
Following function takes as input a gprfile formatted like,
R_EDA	(b1850)
R_THD2	(b1602 and b1603)
R_NMNDA	.
R_NAt3_1_PERIOD_5	(b1186)
R_DHAPT	(b2415) and (b1200) and (b1199) and (b2416) and (b1198)
R_OMPHHX	(b2907)
R_SHK3Dr	(b3281) or (b1692)
R_SERD_L	(b3112 and b3111) or (b1814) or (b3708) or (b2797)
R_SPODM	(b3908) or (b1646) or (b1656)
R_ARBabc	(b1900) and (b1898 and b1899) and (b1901)
R_DURIPP	(b4382) or (b4384)
...

and an expression file, where genes given values of 1, -1, or 0 (highly, lowly, moderately expressed), formatted like,
b3821	1
b2920	-1
b2518	-1
b0418	1
b3825	0
b2925	-1
...

It then uses the gpr and expr data to determine two lists: highly and lowly expressed reactions.

These two lists are part of input for Ruppin algorithm.

Depends on pyparsing module and above classes, modified from simpleBool.py, to evaluate gpr statement conditioned on expression data.


"""

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::


#function that given two files, returns two string-lists: highly expressed rxns and lowly expressed rxns
def getRxnExpr (expressionfile, gprfile):
	#this makes regex to identify the genes within the gpr statement (excludes '(' and ')' and whitespace)
	import re
	gene = re.compile(r"""[^(,^),^\s]+""")

	#make mapping from gene to its discrete expression value (low, moderate, high...-1, 0, 1, respectively)
	gene2expr = {}
	rxn2expr = {}
	file = open(expressionfile)
	while True:
		line = file.readline()
		if line == '': break
		line = line.rstrip()
		if line == '': continue
		if line[0] == '#': continue
		col = line.split('\t')
		gene2expr[col[0]] = col[1]

	#open gpr file, go through one step at a time
	hiexpr, lowexpr = {}, {}

	file = open(gprfile)
	while True:
		line = file.readline()
		if line == '': break
		line = line.rstrip()
		if line == '': continue
		if line[0] == '#': continue
		col = line.split('\t')
		
		rxn, gpr1 = col[1], col[2]
		
		#skip illegal reactions
		if 'R_ILL_' == rxn[:6]:
			continue
		
		#gpr might be missing, if so skip this; this is equivalent to 'no data'...
		if gpr1 == '.':
			#print gpr1, '.'
			rxn2expr[rxn] = '0'
			continue

		#parse the gpr into an 'official' python boolean expression and make a string version of expression...
		res = boolExpr.parseString(gpr1)[0]
		stringres = str(res)
		
		#find all the genes in the bool statement, replace each gene in the statement by its expression level...
		genes = re.findall(gene, stringres)
		for g in genes:
			#skip anything in boolean statement that is not a gene...
			if g == 'max' or g == 'min' or g == 'or' or g == 'and':
				continue
				
			#in human model, gene id like '6733' is modified by adding '.1' or '.2' etc., to stand for different transcripts
			#get rid of these if present (i.e., 6733.1 becomes 6733)...	
			#if '.' in g:
			#	lookup_g = g[:g.find('.')]
			#else:
			lookup_g = g
				
			stringres = stringres.replace(g, gene2expr.get(lookup_g, '?'))
			#stringres = stringres.replace(g, gene2expr.get(g, '0'))
		
		#python throws error for expressions that have too many arguments...
		if len(stringres.split()) > 255:
			#print 'Warning: cannot evaluate gpr for ' + rxn + ', too many genes in expression...'
			#print rxn + ' will be in neither hiexpr nor lowexpr'
			#print 
			continue
		
		#now get reaction expression level by evaluating statement...
		#if missing data, skip this rxn (can't classify as high or low)...
		if '?' in stringres:
			continue
		rxnexpr = eval(stringres)
		#print rxn + '\t' + gpr1 + '\t' + str(res) + '\t' + stringres
		#optionally print results to ensure all steps above are correct...
		#print rxn + '\t' + gpr1 + '\t' + str(res) + '\t' + stringres + '\t' + str(rxnexpr)
		rxn2expr[rxn] = str(rxnexpr)
		
		#add rxn to correct list, either highly expressed or lowly expressed...
		if rxnexpr == 1:
			hiexpr[rxn] = 1
		elif rxnexpr == -1:
			lowexpr[rxn] = -1
		
	
	#return the stringed-lists...				
	return (' ').join(hiexpr.keys()), (' ').join(lowexpr.keys()), rxn2expr
	#return dictionaries
	#return hiexpr, lowexpr

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::

efile = 'eco.exprSample.txt'
gprfile = 'eco.gpr.raw'

if __name__ == '__main__':
	hi, low = getRxnExpr(efile, gprfile)
	print hi
	print 
	print low

