"""
Metmodel v1.1	
mapGPR_current
08-04-2010

"""
#
# simpleBool.py
#
# Example of defining a boolean logic parser using
# the operatorGrammar helper method in pyparsing.
#
# In this example, parse actions associated with each
# operator expression will "compile" the expression
# into BoolOperand subclass objects, which can then
# later be evaluated for their boolean value.
#
# Copyright 2006, by Paul McGuire
#

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Seth added some changes where indicated
# Boolean expressions must be mapped to max/min expressions, see PMID: 18711341

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

from pyparsing import *


class BoolOperand(object):
	def __init__(self,t):
		self.args = t[0][0::2]

	def __str__(self):
		#CHANGE: separators are now all ',' instead of '|' or '&'
		#sep = " %s " % self.reprsymbol
		sep = ", "
		#CHANGE: pref is either 'max' or 'min' for the case of an expression with 'or' or 'and'
		pref = "%s" % self.prefsymbol
		#CHANGE: end result is returning, not expression like '(a & (b | c))', but now 'min(a, max(b, c))'
		return pref + "(" + sep.join(map(str,self.args)) + ")"
    
class BoolAnd(BoolOperand):
	reprsymbol = '&'
	#CHANGE: added variable prefsymbol, which for 'and' is 'min'
	prefsymbol = 'min'
	def __nonzero__(self):
		for a in self.args:
			if isinstance(a,basestring):
				v = eval(a)
			else:
				v = bool(a)
			if not v:
				return False
		return True

class BoolOr(BoolOperand):
	reprsymbol = '|'
	#CHANGE: added variable prefsymbol, which for 'or' is 'max'
	prefsymbol = 'max'
	def __nonzero__(self):
		for a in self.args:
			if isinstance(a,basestring):
				v = eval(a)
			else:
				v = bool(a)
			if v:
				return True
		return False

class BoolNot(BoolOperand):
	def __init__(self,t):
		self.arg = t[0][1]
	def __str__(self):
		return "~" + str(self.arg)
	def __nonzero__(self):
		if isinstance(self.arg,basestring):
			v = eval(self.arg)
		else:
			v = bool(self.arg)
		return not v

#CHANGE: the Word below was changed from 'alphas' so that it would match most gene names...
#Will match any gene name consisting of alphanums plus any of following characters: .+-_()
boolOperand = Word( srange("[A-Za-z0-9.-_]") ) | oneOf("True False")
boolExpr = operatorPrecedence( boolOperand,
	[
	("not", 1, opAssoc.RIGHT, BoolNot),
	("and", 2, opAssoc.LEFT,  BoolAnd),
	("or",  2, opAssoc.LEFT,  BoolOr),
	])


#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::

"""
Following function takes as input a gprfile formatted like,
rg	R_G1PACT	Cthe_2629
rg	R_AGPATr_CT	Cthe_0713
rg	R_UAGCVT	(Cthe_2615 or Cthe_0973) or (Cthe_0441 or Cthe_2328)
rg	R_DAGK_CT	.
rg	R_UDCPKr	Cthe_2305
rg	R_G3PCT	.
rg	R_PHCYT_CT	Cthe_1000 or Cthe_0030
...

and an expression file, where genes are given values corresponding to gene expression level:
Cthe_2348	3.456913183
Cthe_3078	1.524276041
Cthe_0423	1.437619229
Cthe_3077	1.273511958
Cthe_0426	1.155688623
Cthe_1020	1.110949964
Cthe_0424	1.100133511
...

It then uses the gpr and expr data to determine two lists: highly and lowly expressed reactions.

These two lists are part of input for Ruppin algorithm and are returned as dictionaries.

Depends on pyparsing module and above classes, modified from simpleBool.py, to evaluate gpr statement conditioned on expression data.

==============
Update notes:
==============

08-09-2010:
	Modified by Chris to read quantitative expression file, instead of boolean expression file.  The function now must also be given a gamma
	value, which should prevent older scripts from accidentally handing it the wrong expression file type.
"""

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#function that given two files, returns two dictionaries: highly expressed rxns and lowly expressed rxns
#02.19.2010: this function was copied from getRxnExpr() and modified to return the complete dictionaries rather than list-strings, because this is what ruppinFVA appears to expect.  -Chris
def getRxnExprDict (expressionfile, simpleGPR, gammas):
	#this makes regex to identify the genes within the gpr statement (excludes '(' and ')' and whitespace)
	import re
	#gene = re.compile(r"""[^(,^),^\s]+""")
	geneRE = re.compile(r"[^(,^),^\s]+")
	#interpret gammas, should be back-compatible:
	assert type(gammas)==type(()), "Gammas must be given as a tuple containing (low cutoff, high cutoff)"
	(gammaL, gammaH) = gammas
	#make mapping from gene to its discrete expression value (low, moderate, high...-1, 0, 1, respectively)
	gene2expr = {}
	file = open(expressionfile)
	while True:
		line = file.readline()
		if line == '': break
		line = line.rstrip()
		if line == '': continue
		if line[0] == '#': continue
		col = line.split('\t')
		gene, expr = col[0], col[1]
		if float(expr) <= gammaL:
			call='-1'
		elif float(expr) >= gammaH:
			call='1'
		else:	
			call='0'
		gene2expr[gene] = call

	#open gpr file, go through one step at a time
	hiexpr, lowexpr = {}, {}
	for rxn in simpleGPR:
		gpr1 = simpleGPR[rxn]
				
		#gpr might be missing, if so skip this...
		if gpr1 == '.':
			continue

		#parse the gpr into an 'official' python boolean expression and make a string version of expression...
		res = boolExpr.parseString(gpr1)[0]
		stringres = str(res)
		
		#find all the genes in the bool statement, replace each gene in the statement by its expression level...
		genes = re.findall(geneRE, stringres)
		for g in genes:
			#skip anything in boolean statement that is not a gene...
			if g == 'max' or g == 'min' or g == 'or' or g == 'and':
				continue
				
			#in human model, gene id like '6733' is modified by adding '.1' or '.2' etc., to stand for different transcripts
			#get rid of these if present (i.e., 6733.1 becomes 6733)...	
			if '.' in g:
				lookup_g = g[:g.find('.')]
			else:
				lookup_g = g
				
			stringres = stringres.replace(g, gene2expr.get(lookup_g, '?'))
			#stringres = stringres.replace(g, gene2expr.get(g, '0'))
		
		#python throws error for expressions that have too many arguments...
		if len(stringres.split()) > 255:
			print 'Warning: cannot evaluate gpr for ' + rxn + ', too many genes in expression...skipping'
			continue
			
		#now get reaction expression level by evaluating statement...
		#if missing data, skip this rxn (can't classify as high or low)...
		if '?' in stringres:
			continue
#		print stringres
		rxnexpr = eval(stringres)

		#print rxn, gpr1, stringres
		
		#optionally print results to ensure all steps above are correct...
		#print rxn + '\t' + gpr1 + '\t' + str(res) + '\t' + stringres + '\t' + str(rxnexpr)
		
		#add rxn to correct list, either highly expressed or lowly expressed...
		if rxnexpr == 1:
			hiexpr[rxn] = 1
		elif rxnexpr == -1:
			lowexpr[rxn] = -1
	
	#return the stringed-lists...				
	return hiexpr, lowexpr
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::

efile = 'eco.exprSample.txt'
gprfile = 'eco.gpr.raw'

if __name__ == '__main__':
	hi, low = getRxnExprDict(efile, gprfile)
	print hi
	print 
	print low

