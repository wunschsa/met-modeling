# Created by: Paul Brooks
# ruppin, writeRuppinLP, flipmembership, readExprFile functions added by: Chris Gowen
# depends on metmodel_current.py, eq_current.py, mapGPR_current.py written by: Seth Roberts
# mapGPR_Chris.py
# solve, build_from_mm2 functions are modified versions of functions from metmodel_current.py written by: Seth Roberts
# Last Modified: July 17, 2013 

# TODO:
# check KEGG/SEED/Palsson metabolite conversion:
  # fix GapFill, GapReed
  # bouncer2 - write queue to file?


# gurobicb is a subclass of cb defined in metmodel_current.py
# this version now requires Python >= 2.5
# requires scipy, numpy, metmodel_current.py, eq_current.py, mapGPR_current.py, booleanParser.py, libyaml, gurobipy

# the intent is for gurobicb to be a subclass of cb that uses Gurobi 


# functions include:
# __init__: initialize gurobicb object, with EQUATIONS dict for keeping track of string equations
# build_from_mm2: build a model from an mm2 file, keeping track of string equations
# buildfromyaml: build a model from a yaml file
# convertMet2KeggIDs: convert metabolites to Kegg IDs
# addTransports: add transport reactions
# setbiomass:
# solve: solve a model with Gurobi
# addColorToKGMLMaps: color reaction links based on flux values
# fbagapnodb: find a minimum-cost set of sources and escapes that gives a solution with at least minbiomass biomass flux
# fbagapdb: find a minimum-cost set of sources, escapes, reactions that gives a solution with at least minbiomass biomass flux
# gapfind: find the set of un-producible metabolites
# gapfill: find a set of reactions from a database of minimum size s.t. a particular metabolite is produced
# gapreed: find a minimum-sized set of sources, escapes, and reactions that gives a solution with at least minbiomass biomass flux
# gaptest: delete a random set of reactions and exchange reactions
# gaptestexch: delete a random set of exchange reactions
# bouncer: generates a bunch of solutions with at least some percentage of biomass produced (doesn't really work)
# testbouncer2: generates alternate optimal solutions for small e. coli model in Lee et al. (2000)
# bouncer2NoRev: generate all alternate optimal solutions, with reversible reactions separated out; don't use this one; use bouncer2 and it will write a second file with non-reversible reaction format
# getMinRxns:
# bouncer2: generate all alternate optimal solutions
# writeBouncerNoRev: takes as input a model and points and writes all points with reversible reactions converted into two uni-directional reactions
# checkbouncer
# testleealtoptcan: generates alteranat optimal solutions for small e. coli model in Lee et al. (2000)
# testleealtopt: generates alteranat optimal solutions for small e. coli model in Lee et al. (2000); does not put into canonical form to begin (all variables nonnegative)
# leealtoptcan: generates alternate optimal solutions with MIP 
# FVA: flux variability analysis
# ruppin: 
#


# add_reaction: modified version of add_reaction for coefficients of 'n'
# populateSv: add the constraints Sv = 0 to a gurobi problem
# populateSvNoRev: add the constraints Sv = 0 to a gurobi problem, reversible reactions are separated
# writeSparseS: write the coefficient matrix
# populategap: add constraints to the gap model
# gapcost: calculate source and escape cost for metabolites based on "distance" from the biomass reaction
# readLowCostMetabolites: read low cost metabolites from LowCostMetabolites.txt
# readReactionDB: read SEED/KEGG reaction database from Model-SEED-reactions-db.txt
# readMetaboliteDB: read SEED/KEGG/Palsson metabolite database from compound_database_v2.txt
# addreactionsdb: read reactions from database and add to model
# addDBConstraints: add constraints for fba gap with db
# populateGapFind: add constraints for GapFind
# populateGapFill: add constraints for GapFill
# populateGapReed: add constraints for gapreed
# getActiveReactions: get reactions that can fire in a solution
# writeWil: write the model in a .wil format
# addReactionsFromDb: add a list of reactions from the database to a model
# SEED2KEGGPathways: get pathways from KEGG for a model from ModelSEED
# writeECfile: write file with EC numbers in model
# gpr2: read gpr info from a file; re-write from Seth's function from metmodel_current.py to add 'R_' prefix to reaction names
# writeRuppinLP: Formerly called writemodifiedLP, written by Seth; this writes the LP file to be read by gurobi for the Ruppin algorithm.
# flipmembership: function to flip reaction membership in hi and lo sets
# readExprFile: Read gene expression file and create boolean expression file that is read by gurobicb.ruppin() 

import sys
#sys.path.append("/home/jpbrooks/lib/python")
sys.path.append("/usr/local/sage-4.7.1/local/lib/python2.6/site-packages")

import metabolite

from copy import deepcopy
from numpy import matrix, linalg, linspace
#from scipy.linalg import *
#from scipy.sparse import *
from scipy import *
from gurobipy import *
#from restful_lib import Connection # http://exploringlifedata.blogspot.com, used in updateReactionDB.py
import xml.etree.ElementTree as ET
import matplotlib
matplotlib.use('agg')
from pylab import get_cmap
from matplotlib.colors import rgb2hex
import matplotlib.cm as cm
import os
import csv

#from csc.divisi.labeled_view import make_sparse_labeled_tensor

import os, sys, time, string, re, math, random
try:
        from collections import defaultdict
except:
        print "using setdefault"

#import metmodel_current, eq_current, mapGPR_current, booleanParser
import metmodel_current, eq_current, mapGPR_Chris
import yaml

repipe = re.compile(r'\|')
renplus1 = re.compile(r'\(n\+1\)')

#dictionary mapping one letter abbreviation used as suffix on species ID to corresponding compartment				
abbrev2compartment = {
						'c':('Cytosol', 'Extraorganism'),
						'r':('EndoplasmicReticulum', 'Cytosol'),
						'e':('Extraorganism', False),
						'g':('GolgiApparatus', 'Cytosol'),
						'h':('Flagellum', 'Extraorganism'),
						#'l':('Lysosome', 'Cytosol'),
						'l':('Reservosome', 'Cytosol'),
						'm':('Mitochondria', 'Cytosol'),
						'n':('Nucleus', 'Cytosol'),
						#'x':('Peroxisome', 'Cytosol'),
						#'y':('Glycosome', 'Cytosol')
						'x':('Glycosome', 'Cytosol'),
						'v':('Acidocalcisome', 'Cytosol'),
						#'v':('Vacuole', 'Cytosol'),
						'b':('Extraorganism', False),
						'p':('BtwnMitoInnerOuter', 'Cytosol')
}
				

class gurobicb(metmodel_current.cb):
	def __init__ (self, mypath=""):
		self.mypath = mypath
		if mypath != "":
			self.mypath = mypath + "/"
		metmodel_current.cb.__init__(self)
		self.EQUATIONS = {}
		self.metKeggIDs = set()
		self.metSeed2KeggID = {}
		self.metPalsson2KeggID = {}
		self.metKeggID2Palsson = {}
		self.metSeedNames2KeggID = {}
		self.rxnSeedDB = {}
		self.rxnPalssonDB = {}
		self.rxnTransportDB = {}
		self.rxnByKeggID = {}
		gurobicb.readReactionDB(self)
		gurobicb.readMetaboliteDB(self)
	def build_from_mm2(self, mm2file, readquiet=False):
		#this is command to build model from modelfile downloaded from mm2 (includes exchanges, gpr, model)
		# modified from metmodel_current.py for filename conventions, and add reactions here to keep track of equations
		modelfilename = mm2file + '.model.txt'
		modelfile_ = open(modelfilename, 'w')
		gprfilename = mm2file + '.gpr.txt'
		gprfile_ = open(gprfilename, 'w')
		exchangesfilename = mm2file + '.exchanges.txt'
		exchangesfile_ = open(exchangesfilename, 'w')
		file = open(mm2file)
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if line[0] == '#': continue
			if line[:1] == 'R' and len(line.split()) > 3:
				line1 = line.split('\t')
				(id, name, reversibility, pathwaystr, ecstr, stringequation) = line1[0:6]	
				self.EQUATIONS[stringequation] = id
				notes = {}
				pathways = pathwaystr.split(';')
				for pathway in pathways:
					notes['SUBSYSTEM: ' +pathway] = 1
				ecs = ecstr.split(';')
				for ec in ecs:
					notes['EC: ' + ec] = 1
				reversibility, equation = eq_current.parse(stringequation)
				if 'R_ILL_' not in id: 
					gurobicb.add_reaction(self, id, name, reversibility, notes, equation)
				print >>modelfile_, line
				continue
			elif line[:2] == 'rg':
				print >>gprfile_, line
				continue
			else:
				print >>exchangesfile_, line
				continue
		modelfile_.close()
		exchangesfile_.close()
		gprfile_.close()
		gurobicb.exchanges(self, exchangesfilename, readquiet)
		gurobicb.gpr2(self, gprfilename, readquiet)
	def buildfromyaml(self, yamlfname, exchangesfname = ""):
		yamlfile = open(yamlfname, "r")
		yamldata = yaml.load(yamlfile)
		gprFileName = yamlfname+".gpr"
		gprfile = open(gprFileName, "w")
		self.MODEL_NAME = yamlfname
		for record in yamldata:
			if "Reaction" in record["model"]:
				reaction = record["fields"]
				id = reaction["rxnID"]
				name = reaction["name"]
				notes = {}
				ecs = str(reaction["ec"]).split()
				pathways = str(reaction["subsystem"]).split("||")
				for pathway in pathways:
					notes['SUBSYSTEM: ' + pathway] = 1
				for ec in ecs:
					notes['EC: ' + ec] = 1	
				stringequation = reaction["equation"]
				stringequation = repipe.sub('_',stringequation)
				stringequation = renplus1.sub('_n_1', stringequation)
				if stringequation != ".":
					reversibility, equation = eq_current.parse(stringequation)
					if 'R_ILL_' not in id:  # don't add 'illegal' reactions
						gurobicb.add_reaction(self, id, name, reversibility, notes, equation)	
				gprinfo = reaction["gpr"].replace(",", " or ")
				gprfile.write("rg\t%s\t%s\n" % (id,gprinfo))
		gprfile.close()
		gurobicb.gpr2(self, gprFileName, readquiet=False)
		if exchangesfname:
			exchangesfile = open(exchangesfname, "r")
			for line in exchangesfile.readlines():
				if line == '': continue
				if line[0] == '#': continue
				col = line.split()					## starting here, some changes here to cope with MM2 output
				try:
					lb, ub = col[1], col[2]
				except:
					lb, ub = '-1000', '1000'
				rawmet = col[0]
				#convert metabolites from forms like 'leu-L[c]' to 'M_leu_DASH_L_c'...
				met = eq_current.convert_metabolite_ext2int(rawmet)
				if float(lb) < 0.0:
					self.SOURCES.append(met)
				if float(ub) > 0.0:
					self.ESCAPES.append(met)
			self.set_sources(self.SOURCES)	
			self.set_escapes(self.ESCAPES)	

								
	def convertMet2KeggIDs(self):
		myRxnList = list(self.REACTIONS)
		for reaction in myRxnList:
			(name, rev, notes, eq) = self.REACTIONS[reaction]
			neweq = []
			for side in eq:
				newside = []
				for met in side:
					if met[0][:2] == 'M_':
						newmet = (met[0], met[1])
						metname = met[0][2:-2].replace("_DASH_", "-")
					else:
						newmet = ("M_"+met[0],met[1])
						metname = met[0][:-2]
					if metname.lower() not in self.metKeggIDs:
						if self.metSeed2KeggID.has_key(metname.lower()):
							newmet = ("M_"+self.metSeed2KeggID[metname.lower()]+"_"+met[0][-1:],met[1])
						elif self.metPalsson2KeggID.has_key(metname.lower()):
							newmet = ("M_"+self.metPalsson2KeggID[metname.lower()]+"_"+met[0][-1:],met[1])
						elif self.metSeedNames2KeggID.has_key(metname.lower()):
							newmet = ("M_"+self.metSeedNames2KeggID[metname.lower()]+"_"+met[0][-1:],met[1])
						else:
							print metname, "in model reaction but no KEGG ID available"
					newside.append(newmet)
				if len(side) == 0:
					isSource = 1
				neweq.append(newside)
			gurobicb.delete_reaction(self,reaction)
			if len(eq[0]) == 0:
				for met in eq[1]:
					if met[0][:2] == 'M_':
						newmet = met[0]
						metname = met[0][2:-2].replace("_DASH_", "-")
					else:
						newmet = "M_"+met[0]
						metname = met[0][:-2]
					if metname.lower() not in self.metKeggIDs:
						if self.metSeed2KeggID.has_key(metname.lower()):
							newmet = "M_"+self.metSeed2KeggID[metname.lower()]+"_"+met[0][-1:]
						elif self.metPalsson2KeggID.has_key(metname.lower()):
							newmet = "M_"+self.metPalsson2KeggID[metname.lower()]+"_"+met[0][-1:]
						elif self.metSeedNames2KeggID.has_key(metname.lower()):
							newmet = "M_"+self.metSeedNames2KeggID[metname.lower()]+"_"+met[0][-1:]
						else:
							print metname, "in model source but no KEGG ID available"
					self.SOURCES.append(newmet)
			elif len(eq[1]) == 0:
				for met in eq[0]:
					if met[0][:2] == 'M_':
						newmet = met[0]
						metname = met[0][2:-2].replace("_DASH_", "-")
					else:
						newmet = "M_"+met[0]
						metname = met[0][:-2]
					if metname.lower() not in self.metKeggIDs:
						if self.metSeed2KeggID.has_key(metname):
							newmet = "M_"+self.metSeed2KeggID[metname.lower()]+"_"+met[0][-1:]
						elif self.metPalsson2KeggID.has_key(metname.lower()):
							newmet = "M_"+self.metPalsson2KeggID[metname.lower()]+"_"+met[0][-1:]
						elif self.metSeedNames2KeggID.has_key(metname.lower()):
							newmet = "M_"+self.metSeedNames2KeggID[metname.lower()]+"_"+met[0][-1:]
						else:
							print metname, "in model escape but no KEGG ID available"
					self.ESCAPES.append(newmet)
			elif reaction[:2] == 'EX':
				newmet = reaction[3:-2]
				newmetname = name[3:-2].replace(" ", "_")
				if newmet.lower() not in self.metKeggIDs:
					if self.metSeed2KeggID.has_key(newmet.lower()):
						newmet = self.metSeed2KeggID[newmet.lower()]
					elif self.metPalsson2KeggID.has_key(newmetname.lower()):
						newmet = "M_"+self.metPalsson2KeggID[newmetname.lower()]+"_"+name[-1:]
					elif self.metSeedNames2KeggID.has_key(newmetname.lower()):
						newmet = "M_"+self.metSeedNames2KeggID[newmetname.lower()]+"_"+name[-1:]
					else:
						newmet = newmetname
						print newmetname, "exchange in model exchange but no KEGG ID available"
				self.SOURCES.append("M_"+newmet+"_"+reaction[-1:])
				self.ESCAPES.append("M_"+newmet+"_"+reaction[-1:])
			else:
				gurobicb.add_reaction(self, reaction, name, rev, notes, neweq)
		sourceslist = deepcopy(self.SOURCES)
		for i, source in enumerate(sourceslist):
			if source[:2] == 'M_':
				newmet = source
				metname = source[2:-2].replace("_DASH_", "-")
			else:
				newmet = "M_"+ source
				metname = source[:-2]
			if metname.lower() not in self.metKeggIDs:
				if self.metSeed2KeggID.has_key(metname):
					newmet = "M_"+self.metSeed2KeggID[metname.lower()]+"_"+source[-1:]
				elif self.metPalsson2KeggID.has_key(metname.lower()):
					newmet = "M_"+self.metPalsson2KeggID[metname.lower()]+"_"+source[-1:]
				elif self.metSeedNames2KeggID.has_key(metname.lower()):
					newmet = "M_"+self.metSeedNames2KeggID[metname.lower()]+"_"+source[-1:]
				else:
					print source, "source in model but no KEGG ID available"
			self.SOURCES[i] = newmet
		escapeslist = deepcopy(self.ESCAPES)
		for i, escape in enumerate(escapeslist):
			if escape[:2] == 'M_':
				newmet = escape
				metname = escape[2:-2].replace("_DASH_", "-")
			else:
				newmet = "M_"+ escape
				metname = escape[:-2]
			if metname.lower() not in self.metKeggIDs:
				if self.metSeed2KeggID.has_key(metname):
					newmet = "M_"+self.metSeed2KeggID[metname.lower()]+"_"+escape[-1:]
				elif self.metPalsson2KeggID.has_key(metname.lower()):
					newmet = "M_"+self.metPalsson2KeggID[metname.lower()]+"_"+escape[-1:]
				elif self.metSeedNames2KeggID.has_key(metname.lower()):
					newmet = "M_"+self.metSeedNames2KeggID[metname.lower()]+"_"+escape[-1:]
				else:
					print escape, "escape in model but no KEGG ID available"
			self.ESCAPES[i] = newmet
		self.set_sources(self.SOURCES)
		self.set_escapes(self.ESCAPES)
		exchangeslist = deepcopy(self.EXCHANGES)
		self.EXCHANGES = []
		for exchangeinfo in exchangeslist:
			(exchange, lb, ub) = exchangeinfo
			if exchange[:2] == 'M_':
				newmet = exchange
				metname = exchange[2:-2].replace("_DASH_", "-")
			else:
				newmet = "M_"+ exchange
				metname = exchange[:-2]
			if metname.lower() not in self.metKeggIDs:
				if self.metSeed2KeggID.has_key(metname):
					newmet = "M_"+self.metSeed2KeggID[metname.lower()]+"_"+exchange[-1:]
				elif self.metPalsson2KeggID.has_key(metname.lower()):
					newmet = "M_"+self.metPalsson2KeggID[metname.lower()]+"_"+exchange[-1:]
				elif self.metSeedNames2KeggID.has_key(metname.lower()):
					newmet = "M_"+self.metSeedNames2KeggID[metname.lower()]+"_"+exchange[-1:]
				else:
					print exchange, "exchange in model but no KEGG ID available"
			self.EXCHANGES.append((newmet,lb,ub))
		self.set_exchanges(self.EXCHANGES)
				
	def addTransports(self, mode="KEGG"):
		# modes: "Palsson" - use human-readable names, "KEGG" - convert to KEGG IDs when possible using SEED database 
		tfile = open("/usr/local/lib/site-packages/TransportDB.txt", "r")
		for line in tfile.readlines():
			if '#' in line:
				continue
			line = line.rstrip()
			(pathway, ec, id, reversible, name, stringequation) = line.split('\t')
			notes = {}
			notes['SUBSYSTEM: ' + pathway] = 1
			notes['EC: ' + ec] = 1
			reversibility, equation = eq_current.parse(stringequation)
			if mode == "KEGG":
				neweq = []
				for side in equation:
					newside = []
					for met in side:
						newmet = (met[0],met[1])
						checkmet = met[0][2:-2]
						checkmet = checkmet.replace("_DASH_", "-")
						if self.metPalsson2KeggID.has_key(checkmet.lower()):
							newmet = ("M_"+self.metPalsson2KeggID[checkmet.lower()]+"_"+met[0][-1:],met[1])
						elif self.metSeedNames2KeggID.has_key(checkmet.lower()):
							newmet = ("M_"+self.metSeedNames2KeggID[checkmet.lower()]+"_"+met[0][-1:],met[1])
						else:
							print checkmet.lower(), newmet[0], "in transportDB but no KEGG ID"
						newside.append(newmet)
					neweq.append(newside)
				gurobicb.add_reaction(self, id, name, reversibility, notes, neweq)
			else:
				gurobicb.add_reaction(self, id, name, reversibility, notes, equation)

	def setbiomass(self, filename):
		biomassFile = open(filename, "r")
		line = biomassFile.readline()
		stringequation = line.rstrip()
		reversibility, equation = eq_current.parse(stringequation)
		gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1},equation)	
				
	def solve (self, out=False, verbose=True, maps=False):
		epsilon = 0.00001
		#Paul commented this out
		#if self.ESCAPES == [] and self.EXCHANGES == []:
		#	print '# No escapes currently specified. Adding escape fluxes to all metabolites in model.'
		#	gurobicb.set_escapes(self, self.SPECIES.keys())

		#make timestamp...
		timestamp = time.strftime("%Y_%m_%d_%H_%M_%S")
			
		if out:
			#set names of outputfiles
			lpfilename = out + '.' + timestamp + '.lp'
			xlsfilename = out + '.' + timestamp + '.xls'
			
		else:
			#if out not specified, make tmp filenames (these files deleted below in this case)
			lpfilename = 'tmp.' + timestamp + '.lp'
			xlsfilename = 'tmp.' + timestamp + '.xls'
			
  		# define and populate model 
		gurobiprob = Model(lpfilename)
		gurobiprob.ModelSense = -1 
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		if verbose == True:
			gurobicb.writeSparseS(self, gurobiprob, variables, constraints, xlsfilename+".S")
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].setAttr("Obj", 1.0)
		gurobiprob.update()
		#write the *.lp file
		if out:
			gurobiprob.write(lpfilename)
		# solve
		if not out:
			gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()
		self.STATUS = gurobiprob.Status
		if self.STATUS == 2:
			self.OBJECTIVE_VALUE = gurobiprob.ObjVal
			for reaction in self.REACTIONS:
				self.REACTION2FLUXVALUE[reaction] = str(variables[reaction].X)
			for source in self.SOURCES:
				self.REACTION2FLUXVALUE["R_SRC_"+source[2:]] = str(variables["R_SRC_"+source[2:]].X)
			for escape in self.ESCAPES:
				self.REACTION2FLUXVALUE["R_ESC_"+escape[2:]] = str(variables["R_ESC_"+escape[2:]].X)

			#send results to *.xls file
			if out:
				outfile = open(xlsfilename, "w")
				outfile.write("ID\tFlux\tPathways\tECs\tReversible\tName\tEquation\tSEED ID\tKEGG ID\tSEED ECs\tSEED Equation\tSEED Rev\tSEED Name\tNiti ID\tNiti Rev\tNiti Pathway\tNiti ECs\tNiti Equation\tNiti Name\tPalsson ID\tPalsson Rev\tPalsson Pathway\tPalsson ECs\tPalsson Equation\tPalsson Name\tTransport ID\tTransport Rev\tTransport Pathway\tTransport Equation\tTransport Name\tKEGG Name\tKEGG Equation\tKEGG ECs\tKEGG Pathways\n" )
				mysc = "; "
				mytab = "\t"
				for reaction in self.REACTIONS:
					name, reversible, notes, equation = self.REACTIONS[reaction]
					pathways = []
					ecs = []
					for note in notes:
						if 'SUBSYSTEM: ' in note:
							pathways.append(note[11:])
						if 'EC: ' in note:
							ecs.append(note[4:])
					outfile.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t" % (reaction, self.REACTION2FLUXVALUE[reaction], mysc.join(pathways), mysc.join(ecs), str(reversible), name, eq_current.makestring(equation, reversible)))	
					rxnInfo = []
					if reaction in self.rxnByKeggID.keys():
						rxnInfo = self.rxnByKeggID[reaction]	
					elif reaction in self.rxnSeedDB.keys():
						rxnInfo = self.rxnSeedDB[reaction]
					elif reaction in self.rxnPalssonDB.keys():
						rxnInfo = self.rxnPalssonDB[reaction]
					elif reaction in self.rxnTransportDB.keys():
						rxnInfo = self.rxnTransportDB[reaction]
					outfile.write("%s\n" % (mytab.join(rxnInfo)))
				#gurobicb.list_reactions(self, out=xlsfilename, showfluxvalues=True)
			#if you didn't ask to save the output, delete the tmp output files
			if not out:
				if verbose:
					gurobicb.list_reactions(self, out=False, showfluxvalues=True)
			if maps: 
				gurobicb.addColorToKGMLMaps(self, out, variables)
			gurobiprob.__del__()
	def addColorToKGMLMaps(self, out, variables, epsilon = 0.0001):
		fluxByKeggID = {}
		for var in variables:
			if var in self.rxnSeedDB.keys():
				keggID = self.rxnSeedDB[var][1]
			elif var in self.rxnPalssonDB.keys():
				keggID = self.rxnPalssonDB[var][1]
			elif var.startswith("R_SRC_") or var.startswith("R_ESC_"):
				keggID = var[6:-2]
				print var, keggID, variables[var].X
			else:
				keggID = var[2:]
			if keggID == '' or keggID == ".":
				keggID = var[2:]
			fluxByKeggID[keggID] = variables[var].X
		
		#cmap = get_cmap("Spectral")
		#mycolors = cmap(linspace(0.1,0.0,1001.0))
		#for i in xrange(0,10):
		#	print rgb2hex(mycolors[i])

		pathwayMaps = os.listdir("/usr/local/lib/site-packages/maps")
		for pathwayMap in pathwayMaps:
			if out == False:
				outfname = "tmp_" + pathwayMap
			else:
				outfname = out+"_" + pathwayMap
			mytest = ET.parse("/usr/local/lib/site-packages/maps/" + pathwayMap)
			root = mytest.getroot()
			for entry in root.findall('entry'):
				if entry.get('type') == "compound":
					compound = entry.get('name')
					compoundName = compound[4:]
					graphics = entry.find('graphics')
					if compoundName in fluxByKeggID.keys():
						if abs(fluxByKeggID[compoundName]) < epsilon:
							graphics.attrib['bgcolor'] = '#FFFFFF'
						else:
							graphics.attrib['bgcolor'] =str(rgb2hex(cm.Spectral(1.0-abs(fluxByKeggID[compoundName])/1000.))).upper()
				if entry.get('reaction'):
					reactions = entry.get('reaction')
					graphics = entry.find('graphics')
					for reaction in reactions.split():
						rxnName = reaction[3:] 
						if rxnName in fluxByKeggID.keys():
							if abs(fluxByKeggID[rxnName]) < epsilon:
								graphics.attrib['bgcolor'] = '#FFFFFF'
							else:
								graphics.attrib['bgcolor'] =str(rgb2hex(cm.Spectral(1.0-abs(fluxByKeggID[rxnName])/1000.))).upper()
								#print fluxByKeggID[rxnName], str(rgb2hex(cm.Spectral(abs(fluxByKeggID[rxnName]/1000.)))).upper()
								#if abs(fluxByKeggID[rxnName]) > 0.001:
								#	print fluxByKeggID[rxnName], rgb2hex(mycolors[float(int(abs(fluxByKeggID[rxnName])))])
							if fluxByKeggID[rxnName] < 0.0-epsilon:
								graphics.attrib['fgcolor'] = '#FFFFFF'
							
						else:
							graphics.attrib['bgcolor'] = '#8B8989'
			mytest.write(outfname)
	def fbagapnodb (self, addSources=None, addEscapes=None, minbiomass = 0.5, out=False, verbose=True, timelimit=60.0):
		if addSources is None:
			addSources = []
		if addEscapes is None:
			addEscapes = []
		# for finding a minimum-cost set of escapes and sources to get a model with a non-zero solution
		#make timestamp...
		timestamp = time.strftime("%Y_%m_%d_%H_%M_%S")
		if out:
			#set names of outputfiles
			lpfilename = out + '.gap.lp'
			xlsfilename = out + '.gap.xls'
		else:
			#if out not specified, make tmp filenames (these files deleted below in this case)
			lpfilename = 'tmp.gap.lp'
			xlsfilename = 'tmp.gap.xls'
		gurobiprob = Model(lpfilename)
		gurobiprob.ModelSense = 1
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		sCost = {};
		eCost = {};
		notSources = [];
		notEscapes = [];
		handle = gurobicb.populategap(self, gurobiprob, minbiomass, sCost, eCost, notSources, notEscapes, variables, constraints)
		#write the *.lp file
		gurobiprob.write(lpfilename)
		# set time limit
		gurobiprob.Params.TimeLimit = timelimit
		gurobiprob.Params.FeasibilityTol = 1e-7
		gurobiprob.Params.IntFeasTol = 1e-9
		gurobiprob.Params.MIPGap = 0.0
		gurobiprob.Params.OptimalityTol = 1e-9
		gurobiprob.update()
		#solve
		gurobiprob.optimize()
		self.STATUS = gurobiprob.Status
		if (self.STATUS == 2) or (self.STATUS == 9):
			self.OBJECTIVE_VALUE = gurobiprob.ObjVal
			for reaction in self.REACTIONS:
				self.REACTION2FLUXVALUE[reaction] = str(variables[reaction].X)
			for source in self.SOURCES:
				self.REACTION2FLUXVALUE["R_SRC_"+source[2:]] = str(variables["R_SRC_"+source[2:]].X)
			for escape in self.ESCAPES:
				self.REACTION2FLUXVALUE["R_ESC_"+escape[2:]] = str(variables["R_ESC_"+escape[2:]].X)
			#send flux results to *.xls file
			#if out:
			#	gurobicb.list_reactions(self, out=xlsfilename, showfluxvalues=True)
			#if you didn't ask to save the output, delete the tmp output files
			if not out:
				#if verbose:
				#	gurobicb.list_reactions(self, out=False, showfluxvalues=True)
				command1 = 'rm ' + lpfilename
				os.system(command1)
			print "\n\nStatus : ", self.STATUS
			print "\n\nCost : ", self.OBJECTIVE_VALUE 
			print "minbiomass : ", variables["R_biomass_target"].X
			#surely this can be cleaned up	
			for met in self.SPECIES.keys():
				if '_b' == met[-2:]:
					continue
				if variables["_s_" + met].X > 0.5:
					addSources.append(met)
				if variables["_e_" + met].X > 0.5:
					addEscapes.append(met)
			if out:
				# to include fluxes, change w to a
				xlsfile = open(xlsfilename, "w")
				xlsfile.write("added sources:\n")
				for source in addSources:
					xlsfile.write("%s\n" % source);
				xlsfile.write("added escapes:\n")
				for escape in addEscapes:
					xlsfile.write("%s\n" % escape);
			print "Add Sources : ", addSources
			print "Add Escapes : ", addEscapes
			gurobiprob.__del__()
	def fbagapdb (self, addReactions=None, addSources=None, addEscapes=None, minbiomass=0.5, out=False, keepLP=False, verbose=False, timelimit=60.0, modelOut=False, returnResults=False):

		# 08-01-2010, Changes made by Chris:
		#	- modelOut argument specifying output filename of the new model in mm2 format
		#	- if returnResults is set True, function now returns lists of added reactions and exchanges, along with printing them
		#	- fix so that lp file is deleted, even if out is specified
		#	- clean up timestamp from out xlsfilename
		#
		# for finding a minimum-cost set of escapes and sources to get a model with a non-zero solution
		#make timestamp...
		timestamp = time.strftime("%Y_%m_%d_%H_%M_%S")
		if out:
			#set names of outputfiles
			lpfilename = out + '.gap.lp'
			xlsfilename = out + '.gap.xls'
		else:
			#if out not specified, make tmp filenames (these files deleted below in this case)
			lpfilename = 'tmp.gap.lp'
			xlsfilename = 'tmp.gap.xls'
		if not addReactions:
			addReactions = []
		if not addSources:
			addSources = []
		if not addEscapes:
			addEscapes = []
		gurobiprob = Model(lpfilename)
		gurobiprob.ModelSense = 1		
		variables = {}
		constraints = {}
		# read database and add reactions
		dbreactions = {}
		gurobicb.addreactionsdb(self, gurobiprob, dbreactions, variables)
		gurobicb.convertMet2KeggIDs(self)
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		# delete DB reactions from model
		for reaction in dbreactions:
			gurobicb.delete_reaction(self, reaction)
		# add gap constraints and costs
		sCost = {}
		eCost = {}
		notSources = []
		notEscapes = []
		handle = gurobicb.populategap(self, gurobiprob, minbiomass, sCost, eCost, notSources, notEscapes, variables, constraints)
		# add DB reaction constraints
		gurobicb.addDBConstraints(self, gurobiprob, dbreactions, variables, constraints)
		gurobiprob.update()
		#write the *.lp file
		gurobiprob.write(lpfilename)
		# set time limit
		gurobiprob.Params.TimeLimit = timelimit
		gurobiprob.Params.FeasibilityTol = 1e-7
		gurobiprob.Params.IntFeasTol = 1e-9
		gurobiprob.Params.MIPGap = 0.0
		gurobiprob.Params.OptimalityTol = 1e-9
		gurobiprob.Params.Method = 4
		gurobiprob.update()
		#solve
		gurobiprob.optimize()
		self.STATUS = gurobiprob.Status
		print "\n\nStatus : ", self.STATUS
		try:
			self.OBJECTIVE_VALUE = gurobiprob.ObjVal
			print "\n\nCost : ", self.OBJECTIVE_VALUE
			for reaction in self.REACTIONS:
				self.REACTION2FLUXVALUE[reaction] = str(variables[reaction].X)
			for source in self.SOURCES:
				self.REACTION2FLUXVALUE["R_SRC_"+source[2:]] = str(variables["R_SRC_"+source[2:]].X)
			for escape in self.ESCAPES:
				self.REACTION2FLUXVALUE["R_ESC_"+escape[2:]] = str(variables["R_ESC_"+escape[2:]].X)
			#send flux results to *.xls file
			#if out:
			#	gurobicb.list_reactions(self, out=xlsfilename, showfluxvalues=True)
			print "minbiomass : ", variables["R_biomass_target"].X
			#surely this can be cleaned up	
			for met in self.SPECIES.keys():
				if '_b' == met[-2:]:
					continue
				if variables["_s_" + met].X > 0.5:
					addSources.append(met)
				if variables["_e_" + met].X > 0.5:
					addEscapes.append(met)
			for reaction in dbreactions:
				if variables["_r_" + reaction].X > 0.5:
					addReactions.append(deepcopy(reaction))
		except:
			print "FBA gap db failed"
		#if you didn't ask to save the output, delete the tmp output files
		if not keepLP:
			command1 = 'rm ' + lpfilename
			os.system(command1)
		if out:
			xlsfile = open(xlsfilename, "w")
			xlsfile.write("added sources:\n")
			for source in addSources:
				xlsfile.write("%s\n" % source)
			xlsfile.write("added escapes:\n")
			for escape in addEscapes:
				xlsfile.write("%s\n" % escape)
			xlsfile.write("added reactions:\n")
			for reaction in addReactions:
				xlsfile.write("%s\n" % reaction)
		print "Add Sources : ", addSources
		print "Add Escapes : ", addEscapes
		print "Add Reactions : ", addReactions
		#add recommended exchanges
		#newExchanges = []
		#for src in addSources:
		#	if src in self.EXCHANGES:
		#		newExchanges.append((src, '-1000.0', self.EXCHANGES[src][1]))
		#	else:
		#		newExchanges.append((src, '-1000.0', '0.0'))
		#for esc in addEscapes:
		#	if esc in self.EXCHANGES:
		#		newExchanges.append((esc, self.EXCHANGES[esc][0], '1000.0'))
		#	else:
		#		newExchanges.append((esc, '0.0', '1000.0'))
		#self.set_exchanges(newExchanges)

		##add recommended reactions
		#for id in addReactions:
		#	(name, reversibility, notes, equation) = dbreactions[id]
		#	try:
		#		gurobicb.add_reaction(self, id, name, reversibility, notes, equation)
		#	except:
		#		print "Error adding reaction:", id
		#for id in addReactions:
		#	assert id in self.REACTIONS
				
		#if out:
		#	self.solve(verbose=False)
		#	gurobicb.list_reactions(self, out=xlsfilename, showfluxvalues=True)
		#if modelOut:
		#	self.write_mm2( modelOut )
		#if verbose:
		#	gurobicb.list_reactions(self, out=False, showfluxvalues=True)
		if returnResults:
			return addSources, addEscapes, addReactions
		gurobiprob.__del__()
	def gapfind (self, notProduced, out=False, verbose=True, timelimit=60.0):
		#for determining which metabolites cannot be produced in a model
		timestamp = time.strftime("%Y_%m_%d_%H_%M_%S")
		if out:
			#set names of outputfiles
			lpfilename = out + '.' + timestamp + '.gapfind.lp'
			xlsfilename = out + '.' + timestamp + '.gapfind.xls'
		else:
			#if out not specified, make tmp filenames (these files deleted below in this case)
			lpfilename = 'tmp.' + timestamp + '.gapfind.lp'
			xlsfilename = 'tmp.' + timestamp + '.gapfind.xls'
		gurobiprob = Model(lpfilename)
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		eightlist = [] # metabolites for constraints (8)
		handle = gurobicb.populateGapFind(self, gurobiprob, eightlist, variables, constraints)
		#write the *.lp file
		gurobiprob.write(lpfilename)
		## set time limit
		gurobiprob.Params.TimeLimit = timelimit
		# set tolerances, FeasibilityTol can go to 1e-9; commenting out on 2/2 b/c of infeasible instances
		#gurobiprob.Params.FeasibilityTol = 1e-7
		#gurobiprob.Params.IntFeasTol = 1e-9
		#gurobiprob.Params.MIPGap = 0.0
		#gurobiprob.Params.OptimalityTol = 1e-9
		gurobiprob.update()
		##solve
		gurobiprob.optimize()
		self.STATUS = gurobiprob.Status
		print "\n\nStatus : ", self.STATUS
		try:
			self.OBJECTIVE_VALUE = gurobiprob.ObjVal
			for reaction in self.REACTIONS:
				self.REACTION2FLUXVALUE[reaction] = str(variables[reaction].X)
			#send flux results to *.xls file
			if out:
				gurobicb.list_reactions(self, out=xlsfilename, showfluxvalues=True)
			print "\n\nNumber of Producible Metabolites : ", self.OBJECTIVE_VALUE 
			for met in self.SPECIES:
				if met in eightlist:
					if variables[met+"_x8"].X < 0.5:
						notProduced.append(met)
				else: # Kumar et al. call the following "root no-production metbolites" 
					notProduced.append(met)
		except:
			print "GapFind optimization failed\n"
		#if you didn't ask to save the output, delete the tmp output files
		if not out:
			if verbose:
				gurobicb.list_reactions(self, out=False, showfluxvalues=True)
			command1 = 'rm ' + lpfilename
			os.system(command1)
		print "Downstream Un-producible Metabolites : ", len(notProduced), " ", notProduced
		gurobiprob.__del__()
	def gapfill (self, addedReactions, metabolite, out=False, verbose=True, timelimit=60.0):
		#for determining a set of reactions from a database for producing a particular metabolite 
		timestamp = time.strftime("%Y_%m_%d_%H_%M_%S")
		if out:
			#set names of outputfiles
			lpfilename = out + '.' + timestamp + '.gapfill.lp'
			xlsfilename = out + '.' + timestamp + '.gapfill.xls'
		else:
			#if out not specified, make tmp filenames (these files deleted below in this case)
			lpfilename = 'tmp.' + timestamp + '.gapfill.lp'
			xlsfilename = 'tmp.' + timestamp + '.gapfill.xls'
		gurobiprob = Model(lpfilename)
		gurobiprob.ModelSense = 1
		variables = {}
		constraints = {}
		dbreactions = {}
		# read database and add reactions
		handle = gurobicb.populateGapFill(self, metabolite, gurobiprob, variables, constraints, dbreactions)
		#write the *.lp file
		gurobiprob.write(lpfilename)
		## set time limit
		gurobiprob.Params.TimeLimit = timelimit
		# turn off gurobi engine output
		gurobiprob.Params.OutputFlag = 0
		# time between log lines
		gurobiprob.Params.DisplayInterval = 60
		# set tolerances, FeasibilityTol can go to 1e-9
		#gurobiprob.Params.FeasibilityTol = 1e-7
		#gurobiprob.Params.IntFeasTol = 1e-9
		#gurobiprob.Params.MIPGap = 0.0
		#gurobiprob.Params.OptimalityTol = 1e-9
		#gurobiprob.update()
		##solve
		gurobiprob.optimize()
		self.STATUS = gurobiprob.Status
		print "\n\nStatus : ", self.STATUS
		try:
			self.OBJECTIVE_VALUE = gurobiprob.ObjVal
			print "\n\nObjective : ", self.OBJECTIVE_VALUE
			for reaction in self.REACTIONS:
				self.REACTION2FLUXVALUE[reaction] = str(variables[reaction].X)
			#send flux results to *.xls file
			if out:
				gurobicb.list_reactions(self, out=xlsfilename, showfluxvalues=True)
			for reaction in dbreactions:
				if variables["_g_"+reaction].X > 0.5:
					addedReactions.append(deepcopy(reaction))
		except:
			print "Gap Fill failed" # do nothing
		#if you didn't ask to save the output, delete the tmp output files
		if not out:
			if verbose:
				gurobicb.list_reactions(self, out=False, showfluxvalues=True)
			command1 = 'rm ' + lpfilename
			os.system(command1)
		print "Added Reactions : ", addedReactions
		del variables
		del constraints
		del dbreactions
		gurobiprob.__del__()
	def gapreed (self, addReactions, addSources, addEscapes, minbiomass=0.5, out=False, verbose=True, timelimit=60.0): 
		# for finding a minimum-cost set of escapes and sources to get a model with a non-zero solution
		# make timestamp....
		timestamp = time.strftime("%Y_%m_%d_%H_%M_%S")
		if out:
			#set names of outputfiles
			lpfilename = out + '.' + timestamp + '.gapreed.lp'
			xlsfilename = out + '.' + timestamp + '.gapreed.xls'
		else:
			#if out not specified, make tmp filenames (these files deleted below in this case)
			lpfilename = 'tmp.' + timestamp + '.gapreed.lp'
			xlsfilename = 'tmp.' + timestamp + '.gapreed.xls'
		gurobiprob = Model(lpfilename)
		gurobiprob.ModelSense = 1
		variables = {}
		constraints = {}
		# read database and add reactions
		dbreactions = {}
		gurobicb.addreactionsdb(self, gurobiprob, dbreactions, variables)
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints) 
		#delete DB reactions from model
		for reaction in dbreactions:
			gurobicb.delete_reaction(self, reaction)
		# add gap constraints and costs
		handle = gurobicb.populateGapReed(self, gurobiprob, minbiomass, variables, constraints)
		# add DB reaction constraints
		handle = gurobicb.addDBConstraints(self, gurobiprob, dbreactions, variables, constraints)
		#write the *.lp file
		gurobiprob.write(lpfilename)
		## set time limit
		gurobiprob.Params.TimeLimit = timelimit
		# set tolerances, FeasibilityTol can go to 1e-9
		#gurobiprob.Params.FeasibilityTol = 1e-7
		#gurobiprob.Params.IntFeasTol = 1e-9
		#gurobiprob.Params.MIPGap = 0.0
		#gurobiprob.Params.OptimalityTol = 1e-9
		##solve
		gurobiprob.update()
		gurobiprob.optimize()
		self.STATUS = gurobiprob.Status
		print "\n\nStatus : ", self.STATUS
		try:
			print "\n\nCost : ", self.OBJECTIVE_VALUE
			self.OBJECTIVE_VALUE = gurobiprob.ObjVal
			for reaction in self.REACTIONS:
				self.REACTION2FLUXVALUE[reaction] = str(variables[reaction].X)
			for source in self.SOURCES:
				self.REACTION2FLUXVALUE["R_SRC_"+source[2:]] = str(variables["R_SRC_"+source[2:]].X)
			for escape in self.ESCAPES:
				self.REACTION2FLUXVALUE["R_ESC_"+escape[2:]] = str(variables["R_ESC_"+escape[2:]].X)
			#send flux results to *.xls file
			if out:
				gurobicb.list_reactions(self, out=xlsfilename, showfluxvalues=True)
			print "minbiomass : ", variables["R_biomass_target"].X 
			for met in self.SPECIES.keys():
				if '_b' == met[-2:]:
					continue
				if variables["_s_" + met].X > 0.0:
					addSources.append(met)
				if variables["_e_" + met].X > 0.0:
					addEscapes.append(met)
			for reaction in dbreactions:
				if variables["_r_"+reaction].X > 0.0:
					addReactions.append(deepcopy(reaction))
		except:
			print "GapReed infeasible"
		#if you didn't ask to save the output, delete the tmp output files
		if not out:
			if verbose:
				gurobicb.list_reactions(self, out=False, showfluxvalues=True)
			command1 = 'rm ' + lpfilename
			os.system(command1)
		print "Add Sources : ", addSources
		print "Add Escapes : ", addEscapes
		print "Added Reactions : ", addReactions
		gurobiprob.__del__()
	def gaptest (self, deletionpct, deletedreactions, deletedreactionlist, deletedsources, deletedescapes):
		# delete reactions
		reactions = self.REACTIONS.keys()
		delreactionnumbers = []
		while (float(len(delreactionnumbers)) < deletionpct * math.floor(float(len(reactions)))):
			rnumber = random.randrange(0,len(reactions))
			if (rnumber not in delreactionnumbers) and (reactions[rnumber] != "R_biomass_target") and (not reactions[rnumber].startswith('R_SRC_')) and (not reactions[rnumber].startswith('R_ESC_')):
				delreactionnumbers.append(rnumber)
				deletedreactionlist.append(deepcopy(reactions[rnumber]))
				deletedreactions.append((deepcopy(reactions[rnumber]),deepcopy(self.REACTIONS[reactions[rnumber]])))
		for reaction in deletedreactions:
			gurobicb.delete_reaction(self, reaction[0])

		## delete sources	
		#sources = self.SOURCES
		#delsourcenumbers = []
		#while (float(len(delsourcenumbers)) < deletionpct * math.floor(float(len(sources)))):
		#	snumber = random.randrange(0,len(sources))
		#	if snumber not in delsourcenumbers:
		#		delsourcenumbers.append(snumber)
		#		deletedsources.append(deepcopy(self.SOURCES[snumber]))
		#for source in deletedsources:
		#	self.delete_reaction('R_SRC_' + source[2:])
		#	self.SOURCES.remove(source)	

		## delete escapes	
		#escapes = self.ESCAPES
		#delescapenumbers = []
		#while (float(len(delescapenumbers)) < deletionpct * math.floor(float(len(escapes)))):
		#	enumber = random.randrange(0,len(escapes))
		#	if enumber not in delescapenumbers:
		#		delescapenumbers.append(enumber)
		#		deletedescapes.append(deepcopy(self.ESCAPES[enumber]))
		#for escape in deletedescapes:
		#	self.delete_reaction('R_ESC_' + escape[2:])
		#	self.ESCAPES.remove(escape)	
	def gaptestexch (self, deletionpct, deletedsources, deletedescapes):
		# delete deletionpct of the reactions, sources, and escapes
		# delete sources	
		sources = self.SOURCES
		delsourcenumbers = []
		while (float(len(delsourcenumbers)) < deletionpct * math.floor(float(len(sources)))):
			snumber = random.randrange(0,len(sources))
			if snumber not in delsourcenumbers:
				delsourcenumbers.append(snumber)
				deletedsources.append(deepcopy(self.SOURCES[snumber]))
		for source in deletedsources:
			self.delete_reaction('R_SRC_' + source[2:])
			self.SOURCES.remove(source)	

		# delete escapes	
		escapes = self.ESCAPES
		delescapenumbers = []
		while (float(len(delescapenumbers)) < deletionpct * math.floor(float(len(escapes)))):
			enumber = random.randrange(0,len(escapes))
			if enumber not in delescapenumbers:
				delescapenumbers.append(enumber)
				deletedescapes.append(deepcopy(self.ESCAPES[enumber]))
		for escape in deletedescapes:
			self.delete_reaction('R_ESC_' + escape[2:])
			self.ESCAPES.remove(escape)	
	def bouncer (self, biomasspct, numpts, epsilon = 0.0001):
		#epsilon is for determining which eigenvalues are positive and if bounds are satisfied
		print "biomass pct: ", biomasspct
		self.solve(out=False, verbose=False) # get maximum biomass
		biomassMax = self.OBJECTIVE_VALUE
		print "biomass Max: ", biomassMax
		optimalFluxes = self.REACTION2FLUXVALUE
		biomassEquation = self.REACTIONS["R_biomass_target"][3] # store biomass reaction
		self.delete_reaction("R_biomass_target")                # delete original biomass reaction
		# add biomass as a regular reaction
		gurobicb.add_reaction(self, "biomass_temp", "biomass_temp", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 
		activereactions = []  # get reactions that can have flux
		print "Finding Active Reactions ..."
		gurobicb.getActiveReactions (self, activereactions) 
		self.delete_reaction("biomass_temp")                # delete temp biomass reaction
		# add original biomass equation back
		gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 

		# store sparse S matrix, get bounds to check, and get initial point
		lbs = make_sparse_labeled_tensor(ndim=1) 
		ubs = make_sparse_labeled_tensor(ndim=1)
		
		x_i = make_sparse_labeled_tensor(ndim=1)
		x_iplus1 = make_sparse_labeled_tensor(ndim=1)

		sparseS = make_sparse_labeled_tensor(ndim=2)
		for reaction in activereactions: # determine which metabolites are in active reactions
			x_i[reaction] = float(optimalFluxes[reaction])
			equation = self.REACTIONS[reaction][3]	
			for metabolite in equation[0]:
				sparseS[metabolite[0], reaction] = 0.0 - float(metabolite[1])
			for metabolite in equation[1]:
				sparseS[metabolite[0], reaction] = float(metabolite[1])
			ubs[reaction] = float(self.VMAX)
			if bool(self.REACTIONS[reaction][1]):
				lbs[reaction] = 0.0 - float(self.VMAX)
			else:
				lbs[reaction] = 0.0
		# at least biomasspct of biomassMax
		#lbs['R_biomass_target'] = biomasspct * float(biomassMax)
			
		#exchanges are added in when model is built

		# figure out how many columns of V to take
		print "SVD on S matrix ..."
		Ssvd = sparseS.svd(k=len(activereactions))
		for index, sval in enumerate(Ssvd.svals.unwrap()):
			if sval < epsilon:
				Srank = index
				break
		myV = Ssvd.slice(k=Srank).v

		print "Generating points ..."
		mypts = make_sparse_labeled_tensor(ndim=2)
		for i in xrange(1,numpts):
			sys.stdout.write("%d " % (i))
			sys.stdout.flush()
			# generate a new direction 
			deltap = make_sparse_labeled_tensor(ndim=1)
			delta  = make_sparse_labeled_tensor(ndim=1)
			for reaction in activereactions:
				deltap[reaction] = random.random()
			delta = deltap - myV * myV.T * deltap
			# check bounds
			feasflag = 0
			while feasflag == 0:
				feasflag = 1
				x_iplus1 = x_i + delta
				for reaction in activereactions: # check bounds; if infeasible, divide delta by 2
					if (x_iplus1[reaction] - lbs[reaction] < -epsilon) | (x_iplus1[reaction] - ubs[reaction] > epsilon):
						feasflag = 0
						for reaction in activereactions:
							deltap[reaction] = random.random()
						delta = deltap - myV * myV.T * deltap
						#delta = delta * 0.5
						break
			for reaction in activereactions: # could this be done with add_layer?
				if x_i[reaction] != 0.0:
					mypts[i,reaction] = x_i[reaction]
			x_i = x_iplus1
		for reaction in activereactions: # could this be done with add_layer?
			if x_i[reaction] != 0.0:
				mypts[numpts,reaction] = x_i[reaction]
		print "PCA ..."
		mysvd = mypts.svd()
		print mysvd.svals.unwrap()
		print savetxt("temp.txt", mypts.to_dense().unwrap().unwrap())
		
		#t = make_sparse_labeled_tensor(ndim=2)
		#t['A', 'R1'] = -1 
		#t['B', 'R1'] = 1
		#t['A', 'R2'] = -1
		#t['C', 'R2'] = -1
		#t['D', 'R2'] = 2 
		#t['A', 'R3'] = -2
		#t['B', 'R3'] = 2 
		#mysvd = t.svd()
		#myslice = mysvd.slice(k=1)
		#print mysvd.u.unwrap().unwrap()
		#print mysvd.u.unwrap().unwrap()
		#print mysvd.v.unwrap().unwrap()
		#print myslice.u.unwrap().unwrap()
		#print myslice.v.unwrap().unwrap()
		#print mysvd.svals.unwrap()
		#print t.unwrap().unwrap()

		#q = make_sparse_labeled_tensor(ndim=1)
		#q['R1'] = 1.0
		#q['R2'] = 2.0
		#q['R3'] = 3.0
		#s = make_sparse_labeled_tensor(ndim=1)
		#s[0] = 1.0
		#s[1] = 2.0
		#temp = mysvd.v.T * q - s 
		#print temp.unwrap().unwrap()
	def testbouncer2(self): # checks bouncer on lee et al small ecoli example
		outfile = open(self.mypath+self.MODEL_ID+"points.txt", "a")
		epsilon = 0.0000001
		gurobiprob = Model("test")
		gurobiprob.ModelSense = 1
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.Params.OutputFlag = 0
		vars = {}
		cons = {}
		for i in xrange(1,34):
			vars["r"+str(i)] = gurobiprob.addVar(lb=0.0, ub=20.0, name="r"+str(i))
		vars["rATP"] = gurobiprob.addVar(lb=0.0,ub=1000.0, name="rATP")
		gurobiprob.update()
		
		vars["r10"].lb = -20.0
		vars["r33"].lb = -20.0
		vars["r18"].obj=1.0
		cons["5a"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,-1.0],[vars["r1"],vars["r2"],vars["r3"],vars["r10"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5b"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,1.0,1.0],[vars["r10"],vars["r12"],vars["r11"],vars["r7"],vars["r8"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5c"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r14"],vars["r15"],vars["r16"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5d"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0,-1.0,-1.0],[vars["r1"],vars["r16"],vars["r18"],vars["r17"],vars["r31"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5e"] = gurobiprob.addConstr(lhs=LinExpr([1.0,1.0,-1.0,-1.0,-1.0,1.0],[vars["r1"],vars["r18"],vars["r21"],vars["r19"],vars["r20"],vars["r32"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5f"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,1.0,-1.0],[vars["r31"],vars["r24"],vars["r30"],vars["r33"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5g"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,-1.0],[vars["r21"],vars["r24"],vars["r23"],vars["r22"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5h"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0],[vars["r24"],vars["r25"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5i"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r25"],vars["r27"],vars["r26"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5j"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0],[vars["r29"],vars["r27"],vars["r28"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5k"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r2"],vars["r4"],vars["r5"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5l"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0],[vars["r7"],vars["r4"],vars["r6"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5m"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,-1.0,1.0],[vars["r7"],vars["r8"],vars["r5"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5n"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r7"],vars["r8"],vars["r9"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5o"] = gurobiprob.addConstr(lhs=LinExpr([2.0,1.0,-1.0,-1.0],[vars["r12"],vars["r8"],vars["r14"],vars["r13"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5p"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r29"],vars["r33"],vars["r32"]]),sense=GRB.EQUAL, rhs=0.0)

		cons["6a"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r3"]]),sense=GRB.EQUAL, rhs=0.205)
		cons["6b"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r11"]]),sense=GRB.EQUAL, rhs=0.0709)
		cons["6c"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r13"]]),sense=GRB.EQUAL, rhs=0.129)
		cons["6d"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r15"]]),sense=GRB.EQUAL, rhs=1.493)
		cons["6e"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r17"]]),sense=GRB.EQUAL, rhs=0.7191)
		cons["6f"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r6"]]),sense=GRB.EQUAL,  rhs=0.897)
		cons["6g"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r9"]]),sense=GRB.EQUAL,  rhs=0.361)
		cons["6h"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r20"]]),sense=GRB.EQUAL, rhs=2.833)
		cons["6i"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r22"]]),sense=GRB.EQUAL, rhs=2.928)
		cons["6j"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r26"]]),sense=GRB.EQUAL, rhs=1.078)
		cons["6k"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r30"]]),sense=GRB.EQUAL, rhs=1.786)

		cons["7a"] = gurobiprob.addConstr(lhs=LinExpr([2.0,1.0,1.0],[vars["r2"],vars["r25"],vars["r32"]]),sense=GRB.EQUAL, rhs=7.2)
		cons["7b"] = gurobiprob.addConstr(lhs=LinExpr([1.0,1.0,-3.0,-1.0,-1.0,-3.0,-2.0,-2.0,-1.0,-1.0,2.0],[vars["rATP"],vars["r12"],vars["r14"],vars["r18"],vars["r23"],vars["r27"],vars["r21"],vars["r33"],vars["r29"],vars["r31"],vars["r19"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["7c"] = gurobiprob.addConstr(lhs=LinExpr([1.0],[vars["rATP"]]),sense=GRB.GREATER_EQUAL, rhs=13.3)

		gurobiprob.update()

		gurobiprob.optimize()
  		# make sure iteration on variables and constraints is done in same order; sort keys
		varkeys = vars.keys()
		varkeys.sort()
		conkeys = cons.keys()
		conkeys.sort()

		biomassCol = varkeys.index("r18")

		solutions         = [] # list of alternate solutions
		basesChecked      = [] # list of vbasis lists
		enteringVariables = [] # list of entering variables for subproblems
		vBasis            = [] # current basis
		cbasis            = [] # current basis
		Bmatrices         = [] # list of matrices
		vBasisParent      = [] # parent's vbasis
		xs                = [] # solution vectors - change this to sparse rep later?
		xnew              = [] # new candidate solution
		
		# get basis, nonbasic variables with reduced cost 0
		# cbasis = 0 means slack is positive; cbasis = -1 means constraint is tight
		for index, vname in enumerate(varkeys):
			variable = vars[vname]
			xnew.append(variable.X)
			if variable.vbasis == 0:
				vBasis.append(index)
			if (variable.vbasis < 0) and (abs(variable.rc) < epsilon): # create a new subproblem
				if index != biomassCol:
					enteringVariables.append(index)
			outfile.write("%s " % vname)
		outfile.write("\n") 
		for cname in conkeys:
			constraint = cons[cname]
			cbasis.append(constraint.cbasis)
		basesChecked.append(deepcopy(vBasis))
		solutions.append(deepcopy(xnew))
		savetxt(outfile, asmatrix(xnew), fmt="%4.4f")
		#print xnew
		
		# get A
		#A = dok_matrix((len(conkeys), len(varkeys)), dtype=float32)	
		A = []
		nrowA = 0
		for cname in conkeys:
			constraint = cons[cname]
			if constraint.cbasis == -1: # only take constraints that are "tight" in optimal solution
				A.append([])
				for vname in varkeys:
					variable = vars[vname]
					A[nrowA].append(gurobiprob.getCoeff(constraint, variable))
				nrowA = nrowA + 1
		A = asmatrix(A)
		
		#print len(vBasis)
		#print asmatrix(cbasis).sum()
		print "dimension of A:", A.shape

		lbs = []
		ubs = []
		for vname in varkeys:
			variable = vars[vname]
			lbs.append(variable.lb)
			ubs.append(variable.ub)
				
		for index in enteringVariables:
			vBasisParent.append(deepcopy(vBasis))
			xs.append(0)

		while len(enteringVariables) > 0:
			enteringVar = enteringVariables.pop()
			vBasis      = vBasisParent.pop()
			x           = solutions[xs.pop()]
			xnew        = [None]*len(x)
			Bmatrix     = A[:,vBasis]

			# determine if enteringVar is at lower or upper bound
			atLowerBound = 0
			if abs(x[enteringVar] - lbs[enteringVar]) < epsilon:
				atLowerBound = 1
			# get entering column
			a_j = copy(A[:,enteringVar])

			## find entering direction; solve Bd = a_j
			#print "entering var:", enteringVar, varkeys[enteringVar],x[enteringVar], "dimensions of B:", Bmatrix.shape
			d = linalg.solve(Bmatrix,a_j)

			## find largest t such that x + t *d <= ub/lb
			leavingVar = enteringVar
			i = 0
			mint = ubs[enteringVar] - lbs[enteringVar]
			for col in vBasis:
				if abs(d[i]) < epsilon:
					i = i + 1
					continue	
				elif atLowerBound == 1 and d[i] > 0.0:
					t = (x[col] - lbs[col])/float(d[i])
				elif atLowerBound == 1 and d[i] < 0.0:
					t = (x[col] - ubs[col])/float(d[i])
				elif atLowerBound == 0  and d[i] > 0.0:
					t = (ubs[col] - x[col])/float(d[i])
				elif atLowerBound == 0  and d[i] < 0.0:
					t = (lbs[col] - x[col])/float(d[i])
				#print index, float(d[i]), x[index]
				if t < mint:
					mint = t
					leavingVar = col
					leavingVarBcol = i
				i = i + 1
			#print "min t:",mint, "leaving var:",leavingVar, varkeys[leavingVar], x[leavingVar], leavingVarBcol
			if enteringVar == leavingVar:
				print "entering is leaving", enteringVar, leavingVar, "length of queue:", len(xs)
			## set new x
			i = 0
			for index, vname in enumerate(varkeys):
				if index in vBasis:
					if atLowerBound == 1:
						xnew[index] = x[index] - mint*float(d[i])
					else:
						xnew[index] = x[index] + mint*float(d[i])
					i = i + 1
				else:
					xnew[index] = x[index]
			if atLowerBound == 1:
				xnew[enteringVar] = x[enteringVar] + mint
			else:
				xnew[enteringVar] = x[enteringVar] - mint
			# compare basis AND solution to all previous
			newSolution = 1
			newBasis = 1
			solutionNumber = len(solutions)
			if enteringVar == leavingVar:
				newBasis = 0
			else: ## update vbasis,Bmatrix
				vBasis[vBasis.index(leavingVar)] = enteringVar
				vBasis.sort()
				Bmatrix[:,leavingVarBcol] = A[:,enteringVar]
				for basis in basesChecked:
					if vBasis == basis:
						newBasis = 0
						break
			for i, solution in enumerate(solutions):
				check = asmatrix(xnew) - asmatrix(solution)
				if abs(check).sum() < epsilon: # changed 2/20/12
					newSolution = 0
					solutionNumber = i
					break
			if newBasis == 1:
				basesChecked.append(deepcopy(vBasis))
				#savetxt(basisfile, asmatrix(vBasis), fmt="%d")
			if newSolution == 1:
				# record solution
				solutions.append(deepcopy(xnew))
				savetxt(outfile, asmatrix(xnew), fmt="%4.4f")
				outfile.flush()
				print "Number of points:", len(solutions), "Length of queue:", len(xs)
			#print newBasis, newSolution, len(xs)
			if newBasis == 1 or newSolution == 1:
				# solve B^Ty = c
				cB = [0]*len(vBasis)
				if biomassCol in vBasis:
					cB[vBasis.index(biomassCol)] = 1.0
				y = linalg.solve(transpose(Bmatrix), cB)		
				# check which reduced costs are 0, create new problem
				for index, vname in enumerate(varkeys):
					if (index not in vBasis) and (abs(y*A[:,index]) < epsilon):
						if index != biomassCol:
							enteringVariables.append(index)
							vBasisParent.append(deepcopy(vBasis))
							xs.append(solutionNumber)
				# check xnew
				#for constraint in conkeys:
				#	lhs = 0.0
				#	for rnum, reaction in enumerate(varkeys):
				#		coef = gurobiprob.getCoeff(constraints[constraint], variables[reaction])
				#		lhs += coef*float(xnew[rnum])
				#	if abs(lhs) > epsilon:
				#		print "constraint ", constraint, lhs

	def bouncer2NoRev (self, searchStrategy=1, trackDist=False): 
		# to try to replace reversible reaction variables with two non-negative variables; results in an increase in solutions
		# searchStrategy: 1 - "depth"-first search, 2 - "breadth"-first search, 3 - random

		outfile = open(self.mypath + self.MODEL_ID+str(searchStrategy)+"points.txt", "a")
		parentfile = open(self.mypath + self.MODEL_ID+str(searchStrategy)+"parents.txt", "a")
		epsilon = 0.000001
		
		#solve problem with inactive reactions
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()

		############################
		## get reactions that can have flux in an optimal solution
		############################
		biomassEquation = self.REACTIONS["R_biomass_target"][3] # store biomass reaction
		self.delete_reaction("R_biomass_target")                # delete original biomass reaction
		# add biomass as a regular reaction
		gurobicb.add_reaction(self, "biomass_temp", "biomass_temp", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 
		activereactions = []  # get reactions that can have flux
		print "Finding Active Reactions ..."
		gurobicb.getActiveReactions (self, activereactions, gurobiprob.objval) 
		self.delete_reaction("biomass_temp")                # delete temp biomass reaction
		if "biomass_temp" in activereactions:
			activereactions.remove("biomass_temp")
		# delete inactive reactions
		for reaction in set(self.REACTIONS.keys()).difference(set(activereactions)):
			gurobicb.delete_reaction(self, reaction)
		print "numActiveReactions ", len(activereactions)
		# add original biomass equation back
		gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 

		# solve new problem without inactive reactions
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		handle = gurobicb.populateSvNoRev(self, gurobiprob, variables, constraints)
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()

  		# make sure iteration on variables and constraints is done in same order; sort keys
		varkeys = variables.keys()
		varkeys.sort()
		conkeys = constraints.keys()
		conkeys.sort()

		biomassCol = varkeys.index("R_biomass_target")

		solutions         = [] # list of alternate solutions
		basesChecked      = [] # list of vbasis lists
		enteringVariables = [] # list of entering variables for subproblems
		vBasis            = [] # current basis
		cbasis            = [] # current basis
		Bmatrices         = [] # list of matrices
		vBasisParent      = [] # parent's vbasis
		xs                = [] # solution vectors - change this to sparse rep later?
		xnew              = [] # new candidate solution
		xDist             = [] # number of pivots of xs from initial solution
		solDist           = [] # number of pivots of solutions from initial solution
		solParent         = [] # solution number of parent solution
		
		
		# get basis, nonbasic variables with reduced cost 0
		# cbasis = 0 means slack is positive; cbasis = -1 means constraint is tight
		for index, vname in enumerate(varkeys):
			variable = variables[vname]
			xnew.append(variable.X)
			if variable.vbasis == 0:
				vBasis.append(index)
			if (variable.vbasis < 0) and (abs(variable.rc) < epsilon): # create a new subproblem
				enteringVariables.append(index)
			outfile.write("%s " % vname)
		outfile.write("\n") 
		for cname in conkeys:
			constraint = constraints[cname]
			cbasis.append(constraint.cbasis)
		basesChecked.append(deepcopy(vBasis))
		solutions.append(deepcopy(xnew))
		if bool(trackDist) == True:
			solDist.append(0)
		savetxt(outfile, asmatrix(xnew), fmt="%4.4f")
		#print xnew
		
		# get A
		#A = dok_matrix((len(conkeys), len(varkeys)), dtype=float32)	
		A = []
		nrowA = 0
		for cname in conkeys:
			constraint = constraints[cname]
			if constraint.cbasis == -1: # only take constraints that are "tight" in optimal solution
				A.append([])
				for vname in varkeys:
					variable = variables[vname]
					A[nrowA].append(gurobiprob.getCoeff(constraint, variable))
				nrowA = nrowA + 1
		A = asmatrix(A)
		
		#print len(vBasis)
		#print asmatrix(cbasis).sum()
		print "dimension of A:", A.shape

		lbs = []
		ubs = []
		for vname in varkeys:
			variable = variables[vname]
			lbs.append(0.0)
			ubs.append(variable.ub)
				
		for index in enteringVariables:
			vBasisParent.append(deepcopy(vBasis))
			xs.append(0)
			solParent.append(0)
			if bool(trackDist) == True:
				xDist.append(1)

		while len(enteringVariables) > 0:
			if searchStrategy == 1:
				enteringVar = enteringVariables.pop()
				vBasis      = vBasisParent.pop()
				x           = solutions[xs.pop()]
				parent      = solParent.pop()
				if bool(trackDist) == True:
					numPivots   = xDist.pop()	
			elif searchStrategy == 2:
				enteringVar = enteringVariables.pop(0)
				vBasis      = vBasisParent.pop(0)
				x           = solutions[xs.pop(0)]
				parent      = solParent.pop(0)
				if bool(trackDist) == True:
					numPivots   = xDist.pop(0)	
			else:
				myindex = random.randint(0,len(enteringVariables)-1)
				enteringVar = enteringVariables.pop(myindex)
				vBasis      = vBasisParent.pop(myindex)
				x           = solutions[xs.pop(myindex)]
				parent      = solParent.pop(myindex)
				if bool(trackDist) == True:
					numPivots   = xDist.pop(myindex)	
			xnew        = [None]*len(x)
			Bmatrix     = A[:,vBasis]

			# determine if enteringVar is at lower or upper bound
			atLowerBound = 0
			if abs(x[enteringVar] - lbs[enteringVar]) < epsilon:
				atLowerBound = 1
			# get entering column
			a_j = copy(A[:,enteringVar])

			## find entering direction; solve Bd = a_j
			#print "entering var:", enteringVar, varkeys[enteringVar],x[enteringVar], "dimensions of B:", Bmatrix.shape
			d = linalg.solve(Bmatrix,a_j)

			## find largest t such that x + t *d <= ub/lb
			leavingVar = enteringVar
			i = 0
			mint = ubs[enteringVar] - lbs[enteringVar]
			for col in vBasis:
				if abs(d[i]) < epsilon:
					i = i + 1
					continue	
				elif atLowerBound == 1 and d[i] > 0.0:
					t = (x[col] - lbs[col])/float(d[i])
				elif atLowerBound == 1 and d[i] < 0.0:
					t = (x[col] - ubs[col])/float(d[i])
				elif atLowerBound == 0  and d[i] > 0.0:
					t = (ubs[col] - x[col])/float(d[i])
				elif atLowerBound == 0  and d[i] < 0.0:
					t = (lbs[col] - x[col])/float(d[i])
				#print index, float(d[i]), x[index]
				if t < mint:
					mint = t
					leavingVar = col
					leavingVarBcol = i
				i = i + 1
			#print "min t:",mint, "leaving var:",leavingVar, varkeys[leavingVar], x[leavingVar], leavingVarBcol
			if enteringVar == leavingVar:
				print "entering is leaving", enteringVar, leavingVar, "length of queue:", len(xs)
			## set new x
			i = 0
			for index, vname in enumerate(varkeys):
				if index in vBasis:
					if atLowerBound == 1:
						xnew[index] = x[index] - mint*float(d[i])
					else:
						xnew[index] = x[index] + mint*float(d[i])
					i = i + 1
				else:
					xnew[index] = x[index]
			if atLowerBound == 1:
				xnew[enteringVar] = x[enteringVar] + mint
			else:
				xnew[enteringVar] = x[enteringVar] - mint
			# compare basis AND solution to all previous
			newSolution = 1
			newBasis = 1
			solutionNumber = len(solutions)
			if enteringVar == leavingVar:
				newBasis = 0
			else: ## update vbasis,Bmatrix
				vBasis[vBasis.index(leavingVar)] = enteringVar
				vBasis.sort()
				Bmatrix[:,leavingVarBcol] = A[:,enteringVar]
				for basis in basesChecked:
					if vBasis == basis:
						newBasis = 0
						break
			for i, solution in enumerate(solutions):
				check = asmatrix(xnew) - asmatrix(solution)
				if abs(check).sum() < epsilon: # changed 2/20/12
					newSolution = 0
					solutionNumber = i
					break
			if newBasis == 1:
				basesChecked.append(deepcopy(vBasis))
				#savetxt(basisfile, asmatrix(vBasis), fmt="%d")
			if newSolution == 1:
				# record solution
				solutions.append(deepcopy(xnew))
				if bool(trackDist) == True:
					solDist.append(numPivots)
				savetxt(outfile, asmatrix(xnew), fmt="%4.4f")
				outfile.flush()
				parentfile.write("%d\n" % (parent))
				parentfile.flush()
				sys.stdout.write("Number of points: %d Length of queue: %d\n" % (len(solutions), len(xs))) 
				sys.stdout.flush()
			#print newBasis, newSolution, len(xs)
			if newBasis == 1 or newSolution == 1:
				# solve B^Ty = c
				cB = [0]*len(vBasis)
				if biomassCol in vBasis:
					cB[vBasis.index(biomassCol)] = 1.0
				y = linalg.solve(transpose(Bmatrix), cB)		
				# check which reduced costs are 0, create new problem
				for index, vname in enumerate(varkeys):
					if (index not in vBasis) and (abs(y*A[:,index]) < epsilon):
						enteringVariables.append(index)
						vBasisParent.append(deepcopy(vBasis))
						xs.append(solutionNumber)
						if bool(trackDist) == True:
							xDist.append(numPivots+1)
						solParent.append(solutionNumber)
				# check xnew
				#for constraint in conkeys:
				#	lhs = 0.0
				#	for rnum, reaction in enumerate(varkeys):
				#		coef = gurobiprob.getCoeff(constraints[constraint], variables[reaction])
				#		lhs += coef*float(xnew[rnum])
				#	if abs(lhs) > epsilon:
				#		print "constraint ", constraint, lhs
	def getMinRxns(self):
		outfile = open(self.mypath + self.MODEL_ID+"minSolnNoRev.txt", "w")
		# solve FBA problem to get minbiomass
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()

		# get minimum-sized set of reactions
		minprob = Model()
		minprob.ModelSense = 1
		minvariables = {}
		minconstraints = {}
		gurobicb.populateSv(self,minprob, minvariables, minconstraints)
		for reaction in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[reaction]
			minvariables["z_"+reaction] = minprob.addVar(vtype=GRB.BINARY, obj=1.0, name="z_"+reaction)
			minprob.update()
			minconstraints["cz_"+reaction] = minprob.addConstr(lhs=LinExpr([1.0,-float(self.VMAX)],[minvariables[reaction], minvariables["z_"+reaction]]), sense=GRB.LESS_EQUAL, rhs = 0.0)
			minprob.update()
			if bool(reversible) == True:
				minconstraints["cz_"+reaction] = minprob.addConstr(lhs=LinExpr([1.0,float(self.VMAX)],[minvariables[reaction], minvariables["z_"+reaction]]), sense=GRB.GREATER_EQUAL, rhs = 0.0)
				
		minvariables["R_biomass_target"].obj = 0.0
		minvariables["R_biomass_target"].LB = gurobiprob.ObjVal
		#minprob.Params.OutputFlag = 0
		minprob.update()
		minprob.optimize()

		minvarkeys = minvariables.keys()
		revVector = []
		for var in minvarkeys:
			if ("z_" not in var) and ("EXCH" not in var):
				(name,rev,notes,equation) = self.REACTIONS[var]
				rxnname = var
				if bool(rev) == True:
					revVector.append(True)
					outfile.write("%s %s " % (var, var+"_r"))
				else:
					revVector.append(False)
					outfile.write("%s " % var)
		for exchange, lb, ub in self.EXCHANGES:
			if float(ub) > 0.0:
				outfile.write("R_ESC_"+exchange[2:] + " ")
			if float(lb) < 0.0:
				outfile.write("R_SRC_"+exchange[2:] + " ")
		outfile.write("\n")
		index = 0
		for var in minvarkeys:
			if ("z_" not in var) and ("EXCH" not in var):
				if bool(revVector[index]) == True:
					if minvariables[var].X > 0.0:
						outfile.write("%f 0 " % minvariables[var].X)
					else:
						outfile.write("0 %f " % (0.0-minvariables[var].X))
				else:
					outfile.write("%f " % minvariables[var].X)
				index = index + 1
		for exchange, lb, ub in self.EXCHANGES:
			rxnname = "R_EXCH_"+exchange[2:]
			if float(lb) < 0.0:
				if minvariables[rxnname].X < 0.0:
					outfile.write("%f " % (0.0-minvariables[rxnname].X))
				else:
					outfile.write("0 ")
			if float(ub) > 0.0:
				if minvariables[rxnname].X > 0.0:
					outfile.write("%f " % (minvariables[rxnname].X))
				else:
					outfile.write("0 ")
	def bouncer2 (self, searchStrategy=1, trackDist=True, fixedRxnsFluxes = None, out = ""): 
		# enumerate alternate optimal solutions
		# searchStrategy: 1 - "depth"-first search, 2 - "breadth"-first search, 3 - random

		outfile = open(self.mypath + self.MODEL_ID+str(searchStrategy)+out+"points.txt", "a")
		parentfile = open(self.mypath + self.MODEL_ID+str(searchStrategy)+out+"parents.txt", "a")
		fixedfile = open(self.mypath + self.MODEL_ID+str(searchStrategy)+out+"fixedRxns.txt", "a")
		#basisfile = open("hpybasis", "a")
		epsilon = 0.000001

		# solve problem with inactive reactions
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		if fixedRxnsFluxes is None:
			fixedRxnsFluxes = {}
		for rxn in fixedRxnsFluxes.keys():
			self.CONSTRAINTS[rxn] = (fixedRxnsFluxes[rxn],fixedRxnsFluxes[rxn])
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()

		############################
		## get reactions that can have flux in an optimal solution
		############################
		biomassEquation = self.REACTIONS["R_biomass_target"][3] # store biomass reaction
		self.delete_reaction("R_biomass_target")                # delete original biomass reaction

		# add biomass as a regular reaction
		gurobicb.add_reaction(self, "biomass_temp", "biomass_temp", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 
		activereactions = []  
		print "Finding Active Reactions ..."
		gurobicb.getActiveReactions (self, activereactions, gurobiprob.objval,fixedRxnsFluxes) 
		fixedreactions = fixedRxnsFluxes.keys()
		self.delete_reaction("biomass_temp")                # delete temp biomass reaction
		if "biomass_temp" in activereactions:
			activereactions.remove("biomass_temp")
		# delete inactive reactions
		for reaction in set(self.REACTIONS.keys()).difference(set(activereactions)):
			gurobicb.delete_reaction(self, reaction)
		print "numActiveReactions ", len(activereactions)
		# add original biomass equation back
		gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 

		# solve new problem without inactive reactions and fixed reactions
		# do it this way to remove fixed reactions rather than just constrain them
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		
		#define rows
		myrhs = {}
		for met in self.SPECIES.keys():
			if not ('_b' == met[-2:]):
				constraints[met] = gurobiprob.addConstr(lhs = 0.0, sense=GRB.EQUAL, rhs=0.0, name=met)
				myrhs[met] = 0.0	
		gurobiprob.update()
		#add columns
		for ID in self.REACTIONS:
			if ID in fixedreactions:
				name, reversible, notes, equation = self.REACTIONS[ID]
				self.REACTIONS[ID] = (name, reversible, notes, equation)
				metlist = []
				coeflist = [] 
				for reactant in equation[0]:
					species, coef = reactant[0], '-' + str(reactant[1])
					if '_b' == species[-2:]:
						continue
					metlist.append(constraints[species])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					myrhs[species] = myrhs[species]-float(coef)*fixedRxnsFluxes[ID]
				for product in equation[1]:
					species, coef = product[0], product[1]
					if '_b' == species[-2:]:
						continue
					metlist.append(constraints[species])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					myrhs[species] = myrhs[species]-float(coef)*fixedRxnsFluxes[ID]
			else:
				name, reversible, notes, equation = self.REACTIONS[ID]
				self.REACTIONS[ID] = (name, reversible, notes, equation)
				#create constraints, using reaction reversibility and self.VMAX...
				myub = float(self.VMAX)
				if bool(reversible):
					mylb = 0.0-float(self.VMAX)
				else:
					mylb = 0.0
				metlist = []
				coeflist = [] 
				for reactant in equation[0]:
					species, coef = reactant[0], '-' + str(reactant[1])
					if '_b' == species[-2:]:
						continue
					metlist.append(constraints[species])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					coeflist.append(float(coef))
					
				for product in equation[1]:
					species, coef = product[0], product[1]
					if '_b' == species[-2:]:
						continue
					metlist.append(constraints[species])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					coeflist.append(float(coef))
				variables[ID] = gurobiprob.addVar(lb=mylb, ub=myub, obj=0.0, name = ID, column= Column(coeflist, metlist))
		gurobiprob.update()
		for met in self.SPECIES.keys():
			if not ('_b' == met[-2:]):
				constraints[met].rhs = myrhs[met]

		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()
		print "objective ", gurobiprob.ObjVal
		# write fixed reactions to a file
		for reaction in fixedreactions:
			fixedfile.write("%s %f\n" % (reaction, fixedRxnsFluxes[reaction]))
		fixedfile.close()

		#numbasicVars = 0
		#for var in variables:
		#	if variables[var].vbasis == 0:
		#		numbasicVars = numbasicVars + 1
		#print "\nnum basic variables", numbasicVars

		### get non-basic constraints (dual variable is not forced to 0)
		#numbasic = 0
		#nonBasicConstraints = []
		#basicConstraints = []
		#for con in constraints:
		#	print constraints[con].pi, constraints[con].cbasis
		#	if constraints[con].cbasis == 0:
		#		numbasic = numbasic + 1
		#		basicConstraints.append(con)
		#	else:
		#		nonBasicConstraints.append(con)
		#print len(basicConstraints)

		## get minimum-sized set of reactions
		#minprob = Model()
		#minprob.ModelSense = 1
		#minvariables = {}
		#minconstraints = {}
		#gurobicb.populateSv(self,minprob, minvariables, minconstraints)
		#for reaction in self.REACTIONS:
		#	name, reversible, notes, equation = self.REACTIONS[reaction]
		#	minvariables["z_"+reaction] = minprob.addVar(vtype=GRB.BINARY, obj=1.0, name="z_"+reaction)
		#	minprob.update()
		#	print reaction
		#	minconstraints["cz_"+reaction] = minprob.addConstr(lhs=LinExpr([1.0,-float(self.VMAX)],[minvariables[reaction], minvariables["z_"+reaction]]), sense=GRB.LESS_EQUAL, rhs = 0.0)
		#	minprob.update()
		#	if bool(reversible) == True:
		#		minconstraints["cz_"+reaction] = minprob.addConstr(lhs=LinExpr([1.0,float(self.VMAX)],[minvariables[reaction], minvariables["z_"+reaction]]), sense=GRB.GREATER_EQUAL, rhs = 0.0)
		#		
		#minvariables["R_biomass_target"].obj = 0.0
		#minvariables["R_biomass_target"].LB = gurobiprob.ObjVal
		##minprob.Params.OutputFlag = 0
		#minprob.update()
		#minprob.optimize()
		#minrxns = minprob.objval
		#print "minprob objective value: ", minprob.objval
		#addedRxns = []
		#basicURSvars = []
		#mypstart = {}
		#for var in variables:
		#	if "z_" not in var:
		#		mypstart[var] = minvariables[var].X
		#		if minvariables[var].X < minvariables[var].ub-epsilon and minvariables[var].X > minvariables[var].lb+epsilon:
		#			addedRxns.append(var)
		#			if minvariables[var].X > epsilon or minvariables[var].X < -epsilon:
		#				basicURSvars.append(var)
		## add biomass
		#addedRxns.append("R_biomass_target")
		#
		##dual problem to get dual variable values
		#alphaprob = Model()
		#alphaprob.ModelSense = 1
		#alphavariables = {}
		#alphaconstraints = {}
		#for var in variables:
		#	myrhs = 0.0
		#	if "R_biomass_target" in var:
		#		myrhs = 1.0
		#		print "biomass in var"
		#	if var in addedRxns:
		#		alphaconstraints[var] = alphaprob.addConstr(lhs =0.0, sense=GRB.EQUAL, rhs=myrhs)
		#	elif minvariables[var].X > minvariables[var].ub-epsilon:
		#		gamma1 = alphaprob.addVar(obj = variables[var].ub, name="gamma1_"+var)
		#		alphaprob.update()
		#		alphaconstraints[var] = alphaprob.addConstr(lhs=LinExpr([1.0],[gamma1]), sense=GRB.EQUAL, rhs=myrhs)
		#	else:
		#		gamma2 = alphaprob.addVar(obj = -variables[var].lb, name="gamma2_"+var)
		#		alphaprob.update()
		#		alphaconstraints[var] = alphaprob.addConstr(lhs=LinExpr([-1.0],[gamma2]), sense=GRB.EQUAL, rhs=myrhs)
		#alphaprob.update()
		#for con in constraints:
		#	mycons = []
		#	mycoef = []
		#	for var in variables:
		#		mycons.append(alphaconstraints[var])
		#		mycoef.append(gurobiprob.getCoeff(constraints[con], variables[var]))
		#	alphavariables[con] = alphaprob.addVar(lb=-(GRB.INFINITY),obj=0.0, name="alpha_"+con, column=Column(mycoef,mycons))
		#alphaprob.update()
		#alphaprob.optimize()
		#for var in variables:
		#	print var, alphaconstraints[var].pi
		#print "Reduced Costs"
		#for con in constraints:
		#	if alphavariables[con].vbasis < 0:
		#		print con, alphavariables[con].rc
  
		#sys.exit()

	
  		# make sure iteration on variables and constraints is done in same order; sort keys
		varkeys = variables.keys()
		varkeys.sort()
		conkeys = constraints.keys()
		conkeys.sort()

		biomassCol = varkeys.index("R_biomass_target")

		solutions         = [] # list of alternate solutions
		basesChecked      = [] # list of vbasis lists
		enteringVariables = [] # list of entering variables for subproblems
		vBasis            = [] # current basis
		cbasis            = [] # current basis
		Bmatrices         = [] # list of matrices
		vBasisParent      = [] # parent's vbasis
		xs                = [] # solution vectors - change this to sparse rep later?
		xnew              = [] # new candidate solution
		xDist             = [] # number of pivots of xs from initial solution
		solDist           = [] # number of pivots of solutions from initial solution
		solParent         = [] # solution number of parent solution
		
		# get basis, nonbasic variables with reduced cost 0
		# cbasis = 0 means slack is positive; cbasis = -1 means constraint is tight
		for index, vname in enumerate(varkeys):
			variable = variables[vname]
			xnew.append(variable.X)
			if variable.vbasis == 0:
				vBasis.append(index)
			if (variable.vbasis < 0) and (abs(variable.rc) < epsilon): # create a new subproblem
				enteringVariables.append(index)
			outfile.write("%s " % vname)
		outfile.write("\n") 
		#for index, vname in enumerate(varkeys):
		#	outfile.write("%4.4f " % minvars[vname])
		#outfile.write("\n") 
		for cname in conkeys:
			constraint = constraints[cname]
			cbasis.append(constraint.cbasis)
		basesChecked.append(deepcopy(vBasis))
		solutions.append(deepcopy(xnew))
		if bool(trackDist) == True:
			solDist.append(0)
		#numrxns = 0
		#for x in xnew:
		#	if x != 0.0:
		#		numrxns += 1
		savetxt(outfile, asmatrix(xnew), fmt="%4.4f")
		#print xnew
		
		# get A
		#A = dok_matrix((len(conkeys), len(varkeys)), dtype=float32)	
		A = []
		nrowA = 0
		for cname in conkeys:
			constraint = constraints[cname]
			if constraint.cbasis == -1: # only take constraints that are "tight" in optimal solution
				A.append([])
				for vname in varkeys:
					variable = variables[vname]
					A[nrowA].append(gurobiprob.getCoeff(constraint, variable))
				nrowA = nrowA + 1
		A = asmatrix(A)
		
		print len(vBasis), nrowA
	
		#print len(vBasis)
		#print asmatrix(cbasis).sum()
		print "dimension of A:", A.shape

		lbs = []
		ubs = []
		for vname in varkeys:
			variable = variables[vname]
			lbs.append(variable.lb)
			ubs.append(variable.ub)

		for index in enteringVariables:
			vBasisParent.append(deepcopy(vBasis))
			xs.append(0)
			solParent.append(0)
			if bool(trackDist) == True:
				xDist.append(1)

		while len(enteringVariables) > 0:
			if searchStrategy == 1:
				enteringVar = enteringVariables.pop()
				vBasis      = vBasisParent.pop()
				x           = solutions[xs.pop()]
				parent      = solParent.pop()
				if bool(trackDist) == True:
					numPivots   = xDist.pop()	
			elif searchStrategy == 2:
				enteringVar = enteringVariables.pop(0)
				vBasis      = vBasisParent.pop(0)
				x           = solutions[xs.pop(0)]
				parent      = solParent.pop(0)
				if bool(trackDist) == True:
					numPivots   = xDist.pop(0)	
			else:
				myindex = random.randint(0,len(enteringVariables)-1)
				enteringVar = enteringVariables.pop(myindex)
				vBasis      = vBasisParent.pop(myindex)
				x           = solutions[xs.pop(myindex)]
				parent      = solParent.pop(myindex)
				if bool(trackDist) == True:
					numPivots   = xDist.pop(myindex)	
			xnew        = [None]*len(x)
			Bmatrix     = A[:,vBasis]

			# determine if enteringVar is at lower or upper bound
			atLowerBound = 0
			if abs(x[enteringVar] - lbs[enteringVar]) < epsilon:
				atLowerBound = 1
			# get entering column
			a_j = copy(A[:,enteringVar])

			## find entering direction; solve Bd = a_j
			#print "entering var:", enteringVar, varkeys[enteringVar],x[enteringVar], "dimensions of B:", Bmatrix.shape
			d = linalg.solve(Bmatrix,a_j)

			## find largest t such that x + t *d <= ub/lb
			leavingVar = enteringVar
			i = 0
			mint = ubs[enteringVar] - lbs[enteringVar]
			for col in vBasis:
				if abs(d[i]) < epsilon:
					i = i + 1
					continue	
				elif atLowerBound == 1 and d[i] > 0.0:
					t = (x[col] - lbs[col])/float(d[i])
				elif atLowerBound == 1 and d[i] < 0.0:
					t = (x[col] - ubs[col])/float(d[i])
				elif atLowerBound == 0  and d[i] > 0.0:
					t = (ubs[col] - x[col])/float(d[i])
				elif atLowerBound == 0  and d[i] < 0.0:
					t = (lbs[col] - x[col])/float(d[i])
				#print i, float(d[i]), x[col], atLowerBound
				if t < mint:
					mint = t
					leavingVar = col
					leavingVarBcol = i
				i = i + 1
			#print enteringVar, "min t:",mint, "leaving var:",leavingVar, varkeys[leavingVar], x[leavingVar], leavingVarBcol
			if enteringVar == leavingVar:
				print "entering is leaving", enteringVar, leavingVar, "length of queue:", len(xs)
			## set new x
			i = 0
			for index, vname in enumerate(varkeys):
				if index in vBasis:
					if atLowerBound == 1:
						xnew[index] = x[index] - mint*float(d[i])
					else:
						xnew[index] = x[index] + mint*float(d[i])
					i = i + 1
				else:
					xnew[index] = x[index]
			if atLowerBound == 1:
				xnew[enteringVar] = x[enteringVar] + mint
			else:
				xnew[enteringVar] = x[enteringVar] - mint
			# compare basis AND solution to all previous
			newSolution = 1
			newBasis = 1
			solutionNumber = len(solutions)
			if enteringVar == leavingVar:
				newBasis = 0
			else: ## update vbasis,Bmatrix
				vBasis[vBasis.index(leavingVar)] = enteringVar
				vBasis.sort()
				Bmatrix[:,leavingVarBcol] = A[:,enteringVar]
				for basis in basesChecked:
					if vBasis == basis:
						newBasis = 0
						break
			for i, solution in enumerate(solutions):
				check = asmatrix(xnew) - asmatrix(solution)
				if abs(check).sum() < 0.001: # changed 2/20/12
					newSolution = 0
					solutionNumber = i
					break
			if newBasis == 1:
				basesChecked.append(deepcopy(vBasis))
				#savetxt(basisfile, asmatrix(vBasis), fmt="%d")
			if newSolution == 1:
				# record solution
				solutions.append(deepcopy(xnew))
				if bool(trackDist) == True:
					solDist.append(numPivots)
				#numrxns = 0
				###################################################
				#for x in xnew:
				#	if (x > epsilon) or (x < -epsilon):
				#		numrxns += 1
				#if float(numrxns) == minrxns:
				#	print vBasis
				###################################################
				savetxt(outfile, asmatrix(xnew), fmt="%4.4f")
				outfile.flush()
				parentfile.write("%d\n" % (parent))
				parentfile.flush()
				sys.stdout.write("Number of points: %d Length of queue: %d\n" % (len(solutions), len(xs))) 
				sys.stdout.flush()
			#print newBasis, newSolution, len(xs)
			if newBasis == 1 or newSolution == 1:
				# solve B^Ty = c
				cB = [0]*len(vBasis)
				if biomassCol in vBasis:
					cB[vBasis.index(biomassCol)] = 1.0
				y = linalg.solve(transpose(Bmatrix), cB)		
				# check which reduced costs are 0, create new problem
				for index, vname in enumerate(varkeys):
					if (index not in vBasis) and (abs(y*A[:,index]) < epsilon):
						enteringVariables.append(index)
						vBasisParent.append(deepcopy(vBasis))
						xs.append(solutionNumber)
						if bool(trackDist) == True:
							xDist.append(numPivots+1)
						solParent.append(solutionNumber)
						#print vname, index, abs(y*A[:,index])
				# check xnew
				#for constraint in conkeys:
				#	lhs = 0.0
				#	for rnum, reaction in enumerate(varkeys):
				#		coef = gurobiprob.getCoeff(constraints[constraint], variables[reaction])
				#		lhs += coef*float(xnew[rnum])
				#	if abs(lhs) > epsilon:
				#		print "constraint ", constraint, lhs
		outfile.close()
		parentfile.close()
	def writeBouncerNoRev(self, searchStrategy=1, out=""):
		# write a new file with no negative variables
		infile = open(self.mypath + self.MODEL_ID+str(searchStrategy)+out+"points.txt", "r")
		outfile2 = open(self.mypath +self.MODEL_ID+str(searchStrategy)+out+"pointsNoRev.txt", "w")
		fixedfile = open(self.mypath + self.MODEL_ID+str(searchStrategy)+out+"fixedRxns.txt", "r")
		fixedreactions = []
		fixedRxnsFluxes = {}
		for line in fixedfile.readlines():
			line1 = line.split()
			fixedreactions.append(line1[0])
			fixedRxnsFluxes[line1[0]] = float(line1[1])
		revVector = []
		for line in infile.readlines():
			line = line.rstrip()
			if line.startswith("R"):
				basicRxns = line.split()
				for index,rxn in enumerate(basicRxns):
					(name,rev,notes,equation) = self.REACTIONS[rxn]
					if bool(rev) == True:
						revVector.append(True)
						outfile2.write("%s %s " % (rxn, rxn+"_r"))
					else:
						revVector.append(False)
						outfile2.write("%s " % rxn)
				for rxn in fixedreactions:
					(name, rev, notes, equation) = self.REACTIONS[rxn]
					if bool(rev) == True:
						revVector.append(True)
						outfile2.write("%s %s " % (rxn, rxn+"_r"))
					else:
						revVector.append(False)
						outfile2.write("%s " % rxn)
				outfile2.write("\n")
			else:
				line1 = line.split()
				for index,rxn in enumerate(basicRxns):
					if bool(revVector[index]) == True:
						if float(line1[index]) > 0.0:
							outfile2.write("%f 0 " % float(line1[index]))
						else:
							outfile2.write("0 %f " % (0.0-float(line1[index])))
					else:
						outfile2.write("%f " % float(line1[index]))
				for rxn in fixedreactions:
					index = index + 1
					if bool(revVector[index]) == True:
						if fixedRxnsFluxes[rxn] > 0.0:
							outfile2.write("%f 0 " % fixedRxnsFluxes[rxn])
						else:
							outfile2.write("0 %f " % (0.0-fixedRxnsFluxes[rxn]))
					else:
						outfile2.write("%f " % fixedRxnsFluxes[rxn])
				outfile2.write("\n")
		outfile2.close()
		infile.close()
	def checkbouncer (self, bouncerfname):
		solnfile = open(bouncerfname, "r")
		# solve problem with inactive reactions
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()

		# set fixed reactions here ...
		fixedRxnsFluxes = {}
		#fixedRxnsFluxes["R_SUCD3_DASH_u6m"] = -651.405074800 
		#variables["R_SUCD3_DASH_u6m"].lb =    -651.405074800 
		#variables["R_SUCD3_DASH_u6m"].ub =    -651.405074800
		fixedRxnsFluxes["R_SUCD3_DASH_u6m"] = 0.0
		variables["R_SUCD3_DASH_u6m"].lb =    0.0
		variables["R_SUCD3_DASH_u6m"].ub =    0.0

		biomassEquation = self.REACTIONS["R_biomass_target"][3] # store biomass reaction
		self.delete_reaction("R_biomass_target")                # delete original biomass reaction
		# add biomass as a regular reaction
		gurobicb.add_reaction(self, "biomass_temp", "biomass_temp", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 
		activereactions = []  # get reactions that can have flux
		print "Finding Active Reactions ..."
		print fixedRxnsFluxes
		gurobicb.getActiveReactions (self, activereactions, gurobiprob.objval, fixedRxnsFluxes) 
		fixedreactions = fixedRxnsFluxes.keys()
		self.delete_reaction("biomass_temp")                # delete temp biomass reaction
		if "biomass_temp" in activereactions:
			activereactions.remove("biomass_temp")
		# delete inactive reactions
		for reaction in set(self.REACTIONS.keys()).difference(set(activereactions)):
			gurobicb.delete_reaction(self, reaction)
		# add original biomass equation back
		gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 

		# solve new problem without inactive reactions
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		
		#define rows
		myrhs = {}
		for met in self.SPECIES.keys():
			if not ('_b' == met[-2:]):
				constraints[met] = gurobiprob.addConstr(lhs = 0.0, sense=GRB.EQUAL, rhs=0.0, name=met)
				myrhs[met] = 0.0	
		gurobiprob.update()
		#add columns
		for ID in self.REACTIONS:
			if ID in fixedreactions:
				name, reversible, notes, equation = self.REACTIONS[ID]
				self.REACTIONS[ID] = (name, reversible, notes, equation)
				metlist = []
				coeflist = [] 
				for reactant in equation[0]:
					species, coef = reactant[0], '-' + str(reactant[1])
					if '_b' == species[-2:]:
						continue
					metlist.append(constraints[species])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					myrhs[species] = myrhs[species]-float(coef)*fixedRxnsFluxes[ID]
				for product in equation[1]:
					species, coef = product[0], product[1]
					if '_b' == species[-2:]:
						continue
					metlist.append(constraints[species])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					myrhs[species] = myrhs[species]-float(coef)*fixedRxnsFluxes[ID]
			else:
				name, reversible, notes, equation = self.REACTIONS[ID]
				self.REACTIONS[ID] = (name, reversible, notes, equation)
				#create constraints, using reaction reversibility and self.VMAX...
				myub = float(self.VMAX)
				if bool(reversible):
					mylb = 0.0-float(self.VMAX)
				else:
					mylb = 0.0
				metlist = []
				coeflist = [] 
				for reactant in equation[0]:
					species, coef = reactant[0], '-' + str(reactant[1])
					if '_b' == species[-2:]:
						continue
					metlist.append(constraints[species])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					coeflist.append(float(coef))
					
				for product in equation[1]:
					species, coef = product[0], product[1]
					if '_b' == species[-2:]:
						continue
					metlist.append(constraints[species])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					coeflist.append(float(coef))
				variables[ID] = gurobiprob.addVar(lb=mylb, ub=myub, obj=0.0, name = ID, column= Column(coeflist, metlist))
		gurobiprob.update()
		for met in self.SPECIES.keys():
			if not ('_b' == met[-2:]):
				constraints[met].rhs = myrhs[met]

		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()

  		# make sure iteration on variables and constraints is done in same order; sort keys
		varkeys = variables.keys()
		varkeys.sort()
		conkeys = constraints.keys()
		conkeys.sort()
		
		for lineno,line in enumerate(solnfile):
			if lineno!=0:
				epsilon = 0.005
				line1 = line.split()
				###################
				# check biomass   #
				###################
				#print line1[129]
				###################
				# check Sv = 0   #
				###################
				for constraint in conkeys:
					lhs = 0.0
					for rnum, reaction in enumerate(varkeys):
						coef = gurobiprob.getCoeff(constraints[constraint], variables[reaction])
						#print constraint, reaction, line1[rnum], coef
						lhs += coef*float(line1[rnum])
					if abs(lhs-myrhs[constraint]) > epsilon:
						print "line number ", lineno, " constraint ", constraint, lhs, myrhs[constraint]
					#else:
					#	print "line number ", lineno, " constraint ", constraint, lhs, myrhs[constraint]
			


				##########################
				# check v_LB <= v <= v_UB#
				##########################
				for rnum, reaction in enumerate(varkeys):
					if float(line1[rnum]) < variables[reaction].lb:
						print "reaction ", reaction, line1[rnum], " LB ", variables[reaction].lb 
					if float(line1[rnum]) > variables[reaction].ub:
						print "reaction ", reaction, line1[rnum], " UB ", variables[reaction].ub 
	def testleealtoptcan (self): # test lee method with canonical formulation
		epsilon = 0.0000001
		outfile = open("testsol.txt", "w")
		gurobiprob = Model("test")
		gurobiprob.ModelSense = 1
		gurobiprob.Params.OutputFlag = 0
		vars = {}
		cons = {}
		for i in xrange(1,34):
			vars["sL"+str(i)] = gurobiprob.addVar(lb=0.0, name="sL"+str(i))
			vars["sU"+str(i)] = gurobiprob.addVar(lb=0.0, name="sU"+str(i))
		vars["sLATP"] = gurobiprob.addVar(lb=0.0, name="sLATP")
		vars["sUATP"] = gurobiprob.addVar(lb=0.0, name="sUATP")
		vars["s7c"] = gurobiprob.addVar(lb=0.0, name="s7c")

		gurobiprob.update()

		for i in xrange(1,34):
			cons["s"+str(i)] = gurobiprob.addConstr(lhs=LinExpr([1.0,1.0],[vars["sL"+str(i)],vars["sU"+str(i)]]),sense=GRB.EQUAL, rhs=20.0)
		cons["sATP"] = gurobiprob.addConstr(lhs=LinExpr([1.0,1.0],[vars["sLATP"],vars["sUATP"]]),sense=GRB.EQUAL, rhs=1000.0)
		gurobiprob.update()
		cons["s10"].rhs = 40.0
		cons["s33"].rhs = 40.0
		gurobiprob.update()

		vars["sL18"].obj=1.0
		cons["5a"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,-1.0],[vars["sL1"],vars["sL2"],vars["sL3"],vars["sL10"]]),sense=GRB.EQUAL, rhs=-20.0)
		cons["5b"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,1.0,1.0],[vars["sL10"],vars["sL12"],vars["sL11"],vars["sL7"],vars["sL8"]]),sense=GRB.EQUAL, rhs=20.0)
		cons["5c"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["sL14"],vars["sL15"],vars["sL16"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5d"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0,-1.0,-1.0],[vars["sL1"],vars["sL16"],vars["sL18"],vars["sL17"],vars["sL31"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5e"] = gurobiprob.addConstr(lhs=LinExpr([1.0,1.0,-1.0,-1.0,-1.0,1.0],[vars["sL1"],vars["sL18"],vars["sL21"],vars["sL19"],vars["sL20"],vars["sL32"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5f"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,1.0,-1.0],[vars["sL31"],vars["sL24"],vars["sL30"],vars["sL33"]]),sense=GRB.EQUAL, rhs=-20.0)
		cons["5g"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,-1.0],[vars["sL21"],vars["sL24"],vars["sL23"],vars["sL22"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5h"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0],[vars["sL24"],vars["sL25"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5i"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["sL25"],vars["sL27"],vars["sL26"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5j"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0],[vars["sL29"],vars["sL27"],vars["sL28"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5k"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["sL2"],vars["sL4"],vars["sL5"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5l"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0],[vars["sL7"],vars["sL4"],vars["sL6"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5m"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,-1.0,1.0],[vars["sL7"],vars["sL8"],vars["sL5"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5n"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["sL7"],vars["sL8"],vars["sL9"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5o"] = gurobiprob.addConstr(lhs=LinExpr([2.0,1.0,-1.0,-1.0],[vars["sL12"],vars["sL8"],vars["sL14"],vars["sL13"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5p"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["sL29"],vars["sL33"],vars["sL32"]]),sense=GRB.EQUAL, rhs=-20.0)

		cons["6a"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL3"]]),sense=GRB.EQUAL, rhs=0.205)
		cons["6b"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL11"]]),sense=GRB.EQUAL, rhs=0.0709)
		cons["6c"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL13"]]),sense=GRB.EQUAL, rhs=0.129)
		cons["6d"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL15"]]),sense=GRB.EQUAL, rhs=1.493)
		cons["6e"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL17"]]),sense=GRB.EQUAL, rhs=0.7191)
		cons["6f"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL6"]]),sense=GRB.EQUAL,  rhs=0.897)
		cons["6g"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL9"]]),sense=GRB.EQUAL,  rhs=0.361)
		cons["6h"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL20"]]),sense=GRB.EQUAL, rhs=2.833)
		cons["6i"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL22"]]),sense=GRB.EQUAL, rhs=2.928)
		cons["6j"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL26"]]),sense=GRB.EQUAL, rhs=1.078)
		cons["6k"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["sL30"]]),sense=GRB.EQUAL, rhs=1.786)

		cons["7a"] = gurobiprob.addConstr(lhs=LinExpr([2.0,1.0,1.0],[vars["sL2"],vars["sL25"],vars["sL32"]]),sense=GRB.EQUAL, rhs=7.2)
		cons["7b"] = gurobiprob.addConstr(lhs=LinExpr([1.0,1.0,-3.0,-1.0,-1.0,-3.0,-2.0,-2.0,-1.0,-1.0,2.0],[vars["sLATP"],vars["sL12"],vars["sL14"],vars["sL18"],vars["sL23"],vars["sL27"],vars["sL21"],vars["sL33"],vars["sL29"],vars["sL31"],vars["sL19"]]),sense=GRB.EQUAL, rhs=-40.0)
		cons["7c"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0],[vars["s7c"],vars["sLATP"]]),sense=GRB.EQUAL, rhs=-13.3)

		gurobiprob.update()

		gurobiprob.optimize()
		print gurobiprob.Status
		print vars["sL1"].X, vars["sL2"].X, vars["sL10"].X, vars["sL18"].X, vars["sL19"].X, vars["sL23"].X, vars["sL27"].X, vars["sL32"].X, vars["sLATP"].X
		Z1star = gurobiprob.ObjVal

  		# make sure iteration on variables and constraints is done in same order; sort keys
		varkeys = vars.keys()
		#varkeys.sort()
		conkeys = cons.keys()
		#conkeys.sort()

		for var in varkeys:
			outfile.write("%s " % var)
		outfile.write("\n")
		for var in varkeys:
			outfile.write("%4.4f " % vars[var].X)
		outfile.write("\n")

		#get nonzero basic variables
		yvarnames = []
		for index, vname in enumerate(varkeys):
			if (vars[vname].vbasis == 0) and ((vars[vname].X > epsilon) or (vars[vname].X < -epsilon)):
				yvarnames.append(vname)
		for index, vname in enumerate(varkeys):
			# define a variable w for each variable
			vars["w" + vname] = gurobiprob.addVar(lb=0.0,ub=1.0,obj=0.0,name="w"+vname,vtype=GRB.BINARY)
			# define a variable y for each variable; only use the ones for nonzero basic vars
			vars["y" + vname] = gurobiprob.addVar(lb=0.0,ub=1.0,obj=0.0,name="y"+vname,vtype=GRB.BINARY)
			gurobiprob.update()
			# constraint (3) v_i <= U w_i, v_i >= -U w_i
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [vars[vname], vars["w"+ vname]]), sense=GRB.LESS_EQUAL, rhs=0.0)
			## constraint (4) y_i + w_i <= 1
			#gurobiprob.addConstr(lhs=LinExpr([1.0, 1.0], [vars["y"+str(index+1)], vars["w"+str(index+1)]]), sense=GRB.LESS_EQUAL, rhs=1.0)

		#gurobiprob.addConstr(lhs=LinExpr([1.0, float(self.VMAX)], [vars["r10"], vars["wr10"]]), sense=GRB.GREATER_EQUAL, rhs=0.0)
		#gurobiprob.addConstr(lhs=LinExpr([1.0, float(self.VMAX)], [vars["r33"], vars["wr33"]]), sense=GRB.GREATER_EQUAL, rhs=0.0)
		gurobiprob.update()

		wvars = []
		yvars = []
		for name in yvarnames:
			wvars.append(vars["w" + name])
			yvars.append(vars["y" + name])
			
		gurobiprob.update()
		ZK = -10000.0 # current objective
		numsols = 0

		cons3 = {}

		gurobiprob.Params.FeasibilityTol = 1e-9
		gurobiprob.Params.IntFeasTol = 1e-9
		gurobiprob.Params.MIPGap = 0.0
		gurobiprob.Params.OptimalityTol = 1e-9
		while ZK < Z1star + epsilon:
			print "numsols, ZK: ", numsols, ZK
			numsols = numsols + 1
			# constraint (2)
			gurobiprob.addConstr(lhs=LinExpr([1.0]*len(wvars), wvars), sense=GRB.LESS_EQUAL, rhs=len(wvars)-1.0)
			# constraint (1) sum_{i \in NZ} y_i >= 1
			constraint1 = gurobiprob.addConstr(lhs=LinExpr([1.0]*len(yvars), yvars), sense=GRB.GREATER_EQUAL, rhs=1.0, name="constraint1")
			## constraint (4) y_i + w_i <= 1
			cons3 = {}
			for name in yvarnames:
				cons3["y" + name] = gurobiprob.addConstr(lhs=LinExpr([1.0, 1.0], [vars["y"+name], vars["w"+ name]]), sense=GRB.LESS_EQUAL, rhs=1.0)

			gurobiprob.update()
			gurobiprob.optimize()
			ZK = gurobiprob.ObjVal
			print "ZK: ", ZK
			
			# write solution
			for var in varkeys:
				outfile.write("%4.4f " % vars[var].X)
			outfile.write("\n")

			# remove old constraints
			for yvar in yvarnames:
				gurobiprob.remove(cons3["y" + yvar])
			gurobiprob.remove(constraint1)
			# get info for new constraints
			yvarnames = []
			wvars = []
			yvars = []
			for index, vname in enumerate(varkeys):
				if ((vars[vname].X > epsilon) and (vars[vname].X < float(self.VMAX))) or ((vars[vname].X < 0.0-epsilon) and (vars[vname].X > 0.0-float(self.VMAX))):
					yvarnames.append(vname)
					wvars.append(vars["w" + vname])
					yvars.append(vars["y" + vname])
			print vars["sL1"].X, vars["sL2"].X, vars["sL10"].X, vars["sL18"].X, vars["sL19"].X, vars["sL23"].X, vars["sL27"].X, vars["sL32"].X, vars["sLATP"].X
			gurobiprob.update()
		print numsols
	def testleealtopt (self):
		epsilon = 0.0000001
		outfile = open("testsol.txt", "w")
		gurobiprob = Model("test")
		gurobiprob.ModelSense = 1
		gurobiprob.Params.OutputFlag = 0
		vars = {}
		cons = {}
		for i in xrange(1,34):
			vars["r"+str(i)] = gurobiprob.addVar(lb=0.0, ub=20.0, name="r"+str(i))
		vars["rATP"] = gurobiprob.addVar(lb=0.0,ub=1000.0, name="rATP")
		vars["r10minus"] = gurobiprob.addVar(lb=0.0,ub=20.0, name="r10minus")
		vars["r33minus"] = gurobiprob.addVar(lb=0.0,ub=20.0, name="r33minus")

		gurobiprob.update()
		
		#vars["r10"].lb = -20.0
		#vars["r33"].lb = -20.0
		vars["r18"].obj=1.0
		cons["5a"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,-1.0,1.0],[vars["r1"],vars["r2"],vars["r3"],vars["r10"],vars["r10minus"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5b"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,-1.0,1.0,1.0],[vars["r10"],vars["r10minus"],vars["r12"],vars["r11"],vars["r7"],vars["r8"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5c"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r14"],vars["r15"],vars["r16"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5d"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0,-1.0,-1.0],[vars["r1"],vars["r16"],vars["r18"],vars["r17"],vars["r31"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5e"] = gurobiprob.addConstr(lhs=LinExpr([1.0,1.0,-1.0,-1.0,-1.0,1.0],[vars["r1"],vars["r18"],vars["r21"],vars["r19"],vars["r20"],vars["r32"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5f"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,1.0,-1.0,1.0],[vars["r31"],vars["r24"],vars["r30"],vars["r33"],vars["r33minus"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5g"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0,-1.0],[vars["r21"],vars["r24"],vars["r23"],vars["r22"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5h"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0],[vars["r24"],vars["r25"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5i"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r25"],vars["r27"],vars["r26"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5j"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0],[vars["r29"],vars["r27"],vars["r28"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5k"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r2"],vars["r4"],vars["r5"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5l"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,1.0,-1.0],[vars["r7"],vars["r4"],vars["r6"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5m"] = gurobiprob.addConstr(lhs=LinExpr([-1.0,-1.0,1.0],[vars["r7"],vars["r8"],vars["r5"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5n"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,-1.0],[vars["r7"],vars["r8"],vars["r9"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5o"] = gurobiprob.addConstr(lhs=LinExpr([2.0,1.0,-1.0,-1.0],[vars["r12"],vars["r8"],vars["r14"],vars["r13"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["5p"] = gurobiprob.addConstr(lhs=LinExpr([1.0,-1.0,1.0,-1.0],[vars["r29"],vars["r33"],vars["r33minus"],vars["r32"]]),sense=GRB.EQUAL, rhs=0.0)

		cons["6a"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r3"]]),sense=GRB.EQUAL, rhs=0.205)
		cons["6b"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r11"]]),sense=GRB.EQUAL, rhs=0.0709)
		cons["6c"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r13"]]),sense=GRB.EQUAL, rhs=0.129)
		cons["6d"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r15"]]),sense=GRB.EQUAL, rhs=1.493)
		cons["6e"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r17"]]),sense=GRB.EQUAL, rhs=0.7191)
		cons["6f"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r6"]]),sense=GRB.EQUAL,  rhs=0.897)
		cons["6g"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r9"]]),sense=GRB.EQUAL,  rhs=0.361)
		cons["6h"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r20"]]),sense=GRB.EQUAL, rhs=2.833)
		cons["6i"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r22"]]),sense=GRB.EQUAL, rhs=2.928)
		cons["6j"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r26"]]),sense=GRB.EQUAL, rhs=1.078)
		cons["6k"] = gurobiprob.addConstr(lhs=LinExpr([2.5],[vars["r30"]]),sense=GRB.EQUAL, rhs=1.786)

		cons["7a"] = gurobiprob.addConstr(lhs=LinExpr([2.0,1.0,1.0],[vars["r2"],vars["r25"],vars["r32"]]),sense=GRB.EQUAL, rhs=7.2)
		cons["7b"] = gurobiprob.addConstr(lhs=LinExpr([1.0,1.0,-3.0,-1.0,-1.0,-3.0,-2.0,-2.0,2.0,-1.0,-1.0,2.0],[vars["rATP"],vars["r12"],vars["r14"],vars["r18"],vars["r23"],vars["r27"],vars["r21"],vars["r33"],vars["r33minus"],vars["r29"],vars["r31"],vars["r19"]]),sense=GRB.EQUAL, rhs=0.0)
		cons["7c"] = gurobiprob.addConstr(lhs=LinExpr([1.0],[vars["rATP"]]),sense=GRB.GREATER_EQUAL, rhs=13.3)

		gurobiprob.update()

		gurobiprob.optimize()
		print vars["r1"].X, vars["r2"].X, vars["r10"].X, vars["r18"].X, vars["r19"].X, vars["r23"].X, vars["r27"].X, vars["r32"].X, vars["rATP"].X
		Z1star = gurobiprob.ObjVal

  		# make sure iteration on variables and constraints is done in same order; sort keys
		varkeys = vars.keys()
		#varkeys.sort()
		conkeys = cons.keys()
		#conkeys.sort()

		for var in varkeys:
			outfile.write("%s " % var)
		outfile.write("\n")
		for var in varkeys:
			outfile.write("%4.4f " % vars[var].X)
		outfile.write("\n")

		#get nonzero basic variables
		yvarnames = []
		for index, vname in enumerate(varkeys):
			if (vars[vname].vbasis == 0) and ((vars[vname].X > epsilon) or (vars[vname].X < -epsilon)):
				yvarnames.append(vname)
		for index, vname in enumerate(varkeys):
			# define a variable w for each variable
			vars["w" + vname] = gurobiprob.addVar(lb=0.0,ub=1.0,obj=0.0,name="w"+vname,vtype=GRB.BINARY)
			# define a variable y for each variable; only use the ones for nonzero basic vars
			vars["y" + vname] = gurobiprob.addVar(lb=0.0,ub=1.0,obj=0.0,name="y"+vname,vtype=GRB.BINARY)
			gurobiprob.update()
			# constraint (3) v_i <= U w_i, v_i >= -U w_i
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [vars[vname], vars["w"+ vname]]), sense=GRB.LESS_EQUAL, rhs=0.0)
			## constraint (4) y_i + w_i <= 1
			#gurobiprob.addConstr(lhs=LinExpr([1.0, 1.0], [vars["y"+str(index+1)], vars["w"+str(index+1)]]), sense=GRB.LESS_EQUAL, rhs=1.0)

		#gurobiprob.addConstr(lhs=LinExpr([1.0, float(self.VMAX)], [vars["r10"], vars["wr10"]]), sense=GRB.GREATER_EQUAL, rhs=0.0)
		#gurobiprob.addConstr(lhs=LinExpr([1.0, float(self.VMAX)], [vars["r33"], vars["wr33"]]), sense=GRB.GREATER_EQUAL, rhs=0.0)
		gurobiprob.update()

		wvars = []
		yvars = []
		for name in yvarnames:
			wvars.append(vars["w" + name])
			yvars.append(vars["y" + name])
			
		gurobiprob.update()
		ZK = -10000.0 # current objective
		numsols = 0

		cons3 = {}

		gurobiprob.Params.FeasibilityTol = 1e-9
		gurobiprob.Params.IntFeasTol = 1e-9
		gurobiprob.Params.MIPGap = 0.0
		gurobiprob.Params.OptimalityTol = 1e-9
		while ZK < Z1star + epsilon:
			print "numsols, ZK: ", numsols, ZK
			numsols = numsols + 1
			# constraint (2)
			gurobiprob.addConstr(lhs=LinExpr([1.0]*len(wvars), wvars), sense=GRB.LESS_EQUAL, rhs=len(wvars)-1.0)
			# constraint (1) sum_{i \in NZ} y_i >= 1
			constraint1 = gurobiprob.addConstr(lhs=LinExpr([1.0]*len(yvars), yvars), sense=GRB.GREATER_EQUAL, rhs=1.0, name="constraint1")
			## constraint (4) y_i + w_i <= 1
			cons3 = {}
			for name in yvarnames:
				cons3["y" + name] = gurobiprob.addConstr(lhs=LinExpr([1.0, 1.0], [vars["y"+name], vars["w"+ name]]), sense=GRB.LESS_EQUAL, rhs=1.0)

			gurobiprob.update()
			gurobiprob.optimize()
			ZK = gurobiprob.ObjVal
			print "ZK: ", ZK
			
			# write solution
			for var in varkeys:
				outfile.write("%4.4f " % vars[var].X)
			outfile.write("\n")

			# remove old constraints
			for yvar in yvarnames:
				gurobiprob.remove(cons3["y" + yvar])
			gurobiprob.remove(constraint1)
			# get info for new constraints
			yvarnames = []
			wvars = []
			yvars = []
			for index, vname in enumerate(varkeys):
				if ((vars[vname].X > epsilon) and (vars[vname].X < float(self.VMAX))) or ((vars[vname].X < 0.0-epsilon) and (vars[vname].X > 0.0-float(self.VMAX))):
					yvarnames.append(vname)
					wvars.append(vars["w" + vname])
					yvars.append(vars["y" + vname])
			print vars["r1"].X, vars["r2"].X, vars["r10"].X, vars["r18"].X, vars["r19"].X, vars["r23"].X, vars["r27"].X, vars["r32"].X, vars["rATP"].X
			gurobiprob.update()
		print numsols


	def leealtoptcan (self):
		outfile = open(self.mypath +self.MODEL_ID+"points.txt", "w")
		epsilon = 0.0000001
		#biomassEquation = self.REACTIONS["R_biomass_target"][3] # store biomass reaction
		#self.delete_reaction("R_biomass_target")                # delete original biomass reaction
		## add biomass as a regular reaction
		#gurobicb.add_reaction(self, "biomass_temp", "biomass_temp", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 
		#activereactions = []  # get reactions that can have flux
		#print "Finding Active Reactions ..."
		#gurobicb.getActiveReactions (self, activereactions) 
		#self.delete_reaction("biomass_temp")                # delete temp biomass reaction
		#if "biomass_temp" in activereactions:
		#	activereactions.remove("biomass_temp")
		## delete inactive reactions
		#for reaction in set(self.REACTIONS.keys()).difference(set(activereactions)):
		#	gurobicb.delete_reaction(self, reaction)
		## add original biomass equation back
		#gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 

		# solve new problem without inactive reactions
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1 
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()
		Z1star = gurobiprob.ObjVal

  		# make sure iteration on variables and constraints is done in same order; sort keys
		varkeys = variables.keys()
		varkeys.sort()
		conkeys = constraints.keys()
		conkeys.sort()

		# define Lee prob in canonical form
		leeprob = Model("lee")
		leeprob.ModelSense = -1
		leeprob.Params.OutputFlag = 0
		leeprob.Params.FeasibilityTol = 1e-9
		leeprob.Params.IntFeasTol = 1e-9
		leeprob.Params.MIPGap = 0.0
		leeprob.Params.OptimalityTol = 1e-9
		vars = {}
		cons = {}
		biomassCol = varkeys.index("R_biomass_target")
		for vname in varkeys:
			vars["sL"+vname] = leeprob.addVar(lb=0.0, name="sL"+vname)
			vars["sU"+vname] = leeprob.addVar(lb=0.0, name="sU"+vname)
		leeprob.update()
		vars["sLR_biomass_target"].obj = 1.0
		
		# add sL + sU = xU-xL
		for vname in varkeys:
			name, reversible, notes, equation = self.REACTIONS[vname]	
			if bool(reversible):
				myrhs = 2.0*float(self.VMAX)
			else:
				myrhs = float(self.VMAX)
			cons["s"+vname] = leeprob.addConstr(lhs=LinExpr([1.0,1.0],[vars["sL"+vname],vars["sU"+vname]]),sense=GRB.EQUAL,rhs=myrhs)
		leeprob.update()
		
		# add mass balance
		for cname in conkeys:
			myrhs = 0.0
			mycoeffs = []
			myvars   = []
			for vname in varkeys:
				mycoeff = gurobiprob.getCoeff(constraints[cname],variables[vname])
				if mycoeff != 0.0:
					mycoeffs.append(mycoeff)
					myvars.append(vars["sL"+vname])
					name, reversible, notes, equation = self.REACTIONS[vname]	
					if bool(reversible):
						myrhs = myrhs + mycoeff*float(self.VMAX)
			if len(mycoeffs) > 0:
				cons["s"+cname] = leeprob.addConstr(lhs=LinExpr(mycoeffs,myvars), sense=GRB.EQUAL, rhs=myrhs)
		leeprob.update()
	
		leeprob.optimize()
		Z1star = leeprob.ObjVal

		leevarkeys = vars.keys()
		leeconkeys = cons.keys()
		
		for var in leevarkeys:
			outfile.write("%s " % var)
		outfile.write("\n")
		for var in leevarkeys:
			outfile.write("%4.4f " % vars[var].X)
		outfile.write("\n")

		# get nonzero basic variables
		yvarnames = []
		for index, vname in enumerate(leevarkeys):
			if (vars[vname].vbasis == 0) and (vars[vname].X > epsilon):
				yvarnames.append(vname)
		# add y's and w's 
		for index, vname in enumerate(leevarkeys):
			# define a variable w for each variable
			vars["w" + vname] = leeprob.addVar(lb=0.0,ub=1.0,obj=0.0,name="w"+vname,vtype=GRB.BINARY)
			# define a variable y for each variable; only use the ones for nonzero basic vars
			vars["y" + vname] = leeprob.addVar(lb=0.0,ub=1.0,obj=0.0,name="y"+vname,vtype=GRB.BINARY)
			leeprob.update()
			# constraint (3) v_i <= U w_i, v_i >= -U w_i
			leeprob.addConstr(lhs=LinExpr([1.0, -10.0*float(self.VMAX)], [vars[vname], vars["w"+ vname]]), sense=GRB.LESS_EQUAL, rhs=0.0)
			
		leeprob.update()
		
		# store y's and w's for other constraints
		wvars = []
		yvars = []
		for name in yvarnames:
			wvars.append(vars["w" + name])
			yvars.append(vars["y" + name])
			
		leeprob.update()
		ZK = 10000.0 # current objective
		numsols = 0

		cons3 = {}

		while ZK > Z1star - epsilon:
			print "numsols, ZK: ", numsols, ZK
			sys.stdout.flush()
			numsols = numsols + 1
			# constraint (2)
			leeprob.addConstr(lhs=LinExpr([1.0]*len(wvars), wvars), sense=GRB.LESS_EQUAL, rhs=len(wvars)-1.0)
			# constraint (1) sum_{i \in NZ} y_i >= 1
			constraint1 = leeprob.addConstr(lhs=LinExpr([1.0]*len(yvars), yvars), sense=GRB.GREATER_EQUAL, rhs=1.0, name="constraint1")
			## constraint (4) y_i + w_i <= 1
			cons3 = {}
			for name in yvarnames:
				cons3["y" + name] = leeprob.addConstr(lhs=LinExpr([1.0, 1.0], [vars["y"+name], vars["w"+ name]]), sense=GRB.LESS_EQUAL, rhs=1.0)

			leeprob.update()
			#leeprob.write("temp.lp")
			leeprob.optimize()
			ZK = leeprob.ObjVal
			print ZK
			#if numsols == 58:
			#	sys.exit()
			
			# write solution
			for var in leevarkeys:
				outfile.write("%4.4f " % vars[var].X)
			outfile.write("\n")
			outfile.flush()

			# remove old constraints
			for yvar in yvarnames:
				leeprob.remove(cons3["y" + yvar])
			leeprob.remove(constraint1)
			# get info for new constraints
			yvarnames = []
			wvars = []
			yvars = []
			for index, vname in enumerate(leevarkeys):
				if vars[vname].X > epsilon:
					yvarnames.append(vname)
					wvars.append(vars["w" + vname])
					yvars.append(vars["y" + vname])
			leeprob.update()
			#print len(yvars)
		print numsols
	def FVA (self, out = ""):
		# flux variance analysis
		outfile = open(self.mypath + self.MODEL_ID+out+"FVA.txt", "w")
		epsilon = 0.000001
		# solve problem with inactive reactions
		gurobiprob = Model("base")
		gurobiprob.ModelSense = -1
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		fixedRxnsFluxes = {}
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].obj = 1.0
		gurobiprob.update()
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.update()
		gurobiprob.optimize()
		print "objective ", gurobiprob.ObjVal
		maxbiomass = gurobiprob.ObjVal
	
		#####################################
		# FVA #
		#####################################
		varkeys = variables.keys()
		varkeys.sort()

		for vname in varkeys:
			outfile.write("%s " % vname)
		outfile.write("\n")
		biomassEquation = self.REACTIONS["R_biomass_target"][3] # store biomass reaction
		self.delete_reaction("R_biomass_target")                # delete original biomass reaction
		# add biomass as a regular reaction
		gurobicb.add_reaction(self, "biomass_temp", "biomass_temp", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 

		for reaction in self.REACTIONS:
			if "biomass_temp" not in reaction:
				name, reversible, notes, equation = self.REACTIONS[reaction] 
				self.delete_reaction(reaction)
				gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", reversible, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, equation) # make it the biomass reaction; note it is not reversible
				################
				# get max flux #
				################
				maxprob = Model("Maxprob")
				maxprob.ModelSense = -1
				variables = {}
				constraints = {}
				gurobicb.populateSv(self, maxprob, variables, constraints)
				#set biomass coefficient to 1.0
				variables["R_biomass_target"].setAttr("Obj", 1.0)
				maxprob.Params.OutputFlag = 0
				maxprob.Params.FeasibilityTol = 1e-9
				maxprob.Params.OptimalityTol = 1e-9
				maxprob.update()
                		# add constraint on min biomass
				variables["biomass_temp"].LB = maxbiomass
				maxprob.update()
				maxprob.optimize()
				myvarkeys = variables.keys()
				myvarkeys.sort()
				xnew = []
				#print varkeys
				for vname in varkeys:
					if vname == "R_biomass_target":
						xnew.append(maxbiomass)
					elif vname != reaction:
						variable = variables[vname]
						xnew.append(variable.X)
					elif vname == reaction:
						variable = variables["R_biomass_target"]
						xnew.append(variable.X)
				savetxt(outfile, asmatrix(xnew), fmt="%4.4f")
				################
				# get min flux #
				################
				maxprob = Model("Maxprob")
				maxprob.ModelSense = 1
				variables = {}
				constraints = {}
				gurobicb.populateSv(self, maxprob, variables, constraints)
				#set biomass coefficient to 1.0
				variables["R_biomass_target"].setAttr("Obj", 1.0)
				maxprob.Params.OutputFlag = 0
				maxprob.Params.FeasibilityTol = 1e-9
				maxprob.Params.OptimalityTol = 1e-9
				maxprob.update()
                		# add constraint on min biomass
				variables["biomass_temp"].LB = maxbiomass
				maxprob.update()
				maxprob.optimize()
				xnew = []
				for vname in varkeys:
					if vname == "R_biomass_target":
						xnew.append(maxbiomass)
					elif vname != reaction:
						variable = variables[vname]
						xnew.append(variable.X)
					elif vname == reaction:
						variable = variables["R_biomass_target"]
						xnew.append(variable.X)
				savetxt(outfile, asmatrix(xnew), fmt="%4.4f")
				self.delete_reaction("R_biomass_target")
				gurobicb.add_reaction(self, reaction, name, reversible, notes, equation)
		
		gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, biomassEquation) 
		outfile.close()
		infile = open(self.mypath + self.MODEL_ID+out+"FVA.txt", "r")
		outfile2 = open(self.mypath + self.MODEL_ID+out+"FVANoRev.txt", "w")
  
		revVector = []
		for line in infile.readlines():
			line = line.rstrip()
			if line.startswith("R"):
				basicRxns = line.split()
				for index,rxn in enumerate(basicRxns):
					(name,rev,notes,equation) = self.REACTIONS[rxn]
					if bool(rev) == True:
						revVector.append(True)
						outfile2.write("%s %s " % (rxn, rxn+"_r"))
					else:
						revVector.append(False)
						outfile2.write("%s " % rxn)
				outfile2.write("\n")
			else:
				line1 = line.split()
				for index,rxn in enumerate(basicRxns):
					if bool(revVector[index]) == True:
						if float(line1[index]) > 0.0:
							outfile2.write("%f 0 " % float(line1[index]))
						else:
							outfile2.write("0 %f " % (0.0-float(line1[index])))
					else:
						outfile2.write("%f " % float(line1[index]))
				outfile2.write("\n")
		outfile2.close()
		infile.close()
		

	def add_reaction (self, ID, name, rev, notes, equation):
		"Add a new reaction into the model. Example: m.make_reaction('R_ss_biomass', 'ssa biomass', 'false', {'CONFIDENCE: 1':1, 'SUBSYSTEM: biomass':1, 'GPR: ':1, 'EC Number: ':1}, [[('M_atp_c', '1')],[('M_adp_c', '1'), ('M_pi_c', '1')]])"
		if ID in self.REACTIONS:
			print ID, 'already in REACTIONS'
		else:
			self.REACTIONS[ID] = (name, rev, notes, equation)
			# got rid of DISCREPANCIES check
			for species, coef in (equation[0] + equation[1]):
				# added this line for yaml files
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				#add compartment if necessary
				if species[-1:] in abbrev2compartment.keys():
					compartment, outside = abbrev2compartment[species[-1:]]
				else:
					print species[-1:], " is not a compartment"
					print "deleting ", ID, equation
					gurobicb.delete_reaction(self, ID)
					break
				if not compartment in self.COMPARTMENTS:
					gurobicb.add_compartment(self, compartment, outside)
				#add species if necessary
				if not species in self.SPECIES:
					name, db_compartment, charge, boundaryCondition = '.', '.', '.', 'false'
					gurobicb.add_species(self, species, name, compartment, charge, boundaryCondition)
	def addReactionsFromDB(self, reactionIDs):
		dbreactions = {} 
		for reaction in self.rxnSeedDB:
			rxnInfo = self.rxnSeedDB[reaction]
			if (reaction not in self.REACTIONS) and (rxnInfo[6] not in self.REACTIONS) and (rxnInfo[12] not in self.REACTIONS) and (rxnInfo[18] not in self.REACTIONS) and (rxnInfo[1] not in self.REACTIONS):
				if rxnInfo[3] != ' <=> ' and not rxnInfo[3].startswith(' =>'):
					rev, equation = eq_current.parse(rxnInfo[3])
					notes = {}
					notes['SUBSYSTEM: .'] = 1
					if rxnInfo[2] == "":
						notes['EC: .'] = 1
					else:
						ecs = rxnInfo[2].split("|")
						for ec in ecs:
							if ec != "":
								notes['EC: ' + ec] = 1
					dbreactions[reaction] = (rxnInfo[5], rxnInfo[4], notes, equation)
		for reaction in self.rxnPalssonDB:
			rxnInfo = self.rxnPalssonDB[reaction]
			if (reaction not in self.REACTIONS) and (rxnInfo[6] not in self.REACTIONS) and (rxnInfo[12] not in self.REACTIONS) and (rxnInfo[18] not in self.REACTIONS) and (rxnInfo[1] not in self.REACTIONS):
				if rxnInfo[10] != ".": # use Niti's equation if possible
					rev, equation = eq_current.parse(rxnInfo[10])
					notes = {}
					if rxnInfo[9] == "":
						notes['EC: .'] = 1
					else:
						ecs = rxnInfo[9].split("; ")
						for ec in ecs:
							if ec != "":
								notes['EC: ' + ec] = 1
					if rxnInfo[8] == "":
						notes['SUBSYSTEM: .'] = 1
					else:
						pathways = rxnInfo[8].split("; ")
						for pathway in pathways:
							if pathway != "":
								notes['SUBSYSTEM: ' + pathway] = 1
					dbreactions[reaction] = (rxnInfo[11], rxnInfo[7], notes, equation)
				else:
					rev, equation = eq_current.parse(rxnInfo[16])
					notes = {}
					if rxnInfo[15] == "":
						notes['EC: .'] = 1
					else:
						ecs = rxnInfo[15].split("; ")
						for ec in ecs:
							if ec != "":
								notes['EC: ' + ec] = 1
					if rxnInfo[14] == "":
						notes['SUBSYSTEM: .'] = 1
					else:
						pathways = rxnInfo[14].split("; ")
						for pathway in pathways:
							if pathway != "":
								notes['SUBSYSTEM: ' + pathway] = 1
					dbreactions[reaction] = (rxnInfo[17], rxnInfo[13], notes, equation)
		for reaction in self.rxnTransportDB:
			rxnInfo = self.rxnTransportDB[reaction]
			if (reaction not in self.REACTIONS) and (rxnInfo[6] not in self.REACTIONS) and (rxnInfo[12] not in self.REACTIONS) and (rxnInfo[18] not in self.REACTIONS) and (rxnInfo[1] not in self.REACTIONS):
				rev, equation = eq_current.parse(rxnInfo[21])
				notes = {}
				if rxnInfo[20] == "":
					notes['SUBSYSTEM: .'] = 1
				else:
					pathways = rxnInfo[20].split("; ")
					for pathway in pathways:
						if pathway != "":
							notes['SUBSYSTEM: ' + pathway] = 1
				dbreactions[reaction] = (rxnInfo[22], rxnInfo[19], notes, equation)
		for reactionToAdd in reactionIDs:
			(name, reversibility, notes, equation) = dbreactions[reactionToAdd]
			gurobicb.add_reaction(self, reactionToAdd, name, reversibility, notes, equation)
			#self.EQUATIONS[stringequation] = reactionToAdd
		gurobicb.convertMet2KeggIDs(self)
	def populateSv (self, gurobiprob, variables, constraints):
		#define rows
		for met in self.SPECIES.keys():
			if not ('_b' == met[-2:]):
				constraints[met] = gurobiprob.addConstr(lhs = 0.0, sense=GRB.EQUAL, rhs=0.0, name=met)
		gurobiprob.update()
		#add columns
		for ID in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[ID]
			pathways = 0
			ecs = 0
			for notekey in  notes.keys():
				if 'SUBSYSTEM' in notekey:
					pathways = 1
				if 'EC' in notekey:
					ecs = 1
			if pathways == 0:
				notes['SUBSYSTEM: .'] = 1
			if ecs == 0:
				notes['EC: .'] = 1
			self.REACTIONS[ID] = (name, reversible, notes, equation)
				
			#if there have been specific constraints already set, use them...
			if ID in self.CONSTRAINTS:
				mylb, myub = self.CONSTRAINTS[ID]
				mylb = float(mylb)
				myub = float(myub)
			#otherwise create constraints on the fly, using reaction reversibility and self.VMAX...
			else:
				myub = float(self.VMAX)
				if bool(reversible):
					mylb = 0.0-float(self.VMAX)
				else:
					mylb = 0.0
			metlist = []
			coeflist = [] 
			for reactant in equation[0]:
				species, coef = reactant[0], '-' + str(reactant[1])
				if '_b' == species[-2:]:
					continue
				metlist.append(constraints[species])
				# for the yaml business
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				coeflist.append(float(coef))
				
			for product in equation[1]:
				species, coef = product[0], product[1]
				if '_b' == species[-2:]:
					continue
				metlist.append(constraints[species])
				# for the yaml business
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				coeflist.append(float(coef))
			variables[ID] = gurobiprob.addVar(lb=mylb, ub=myub, obj=0.0, name = ID, column= Column(coeflist, metlist))
		gurobiprob.update()
	def populateSvNoRev (self, gurobiprob, variables, constraints):
		#define rows
		for met in self.SPECIES.keys():
			if not ('_b' == met[-2:]):
				constraints[met] = gurobiprob.addConstr(lhs = 0.0, sense=GRB.EQUAL, rhs=0.0, name=met)
		gurobiprob.update()
		#add columns
		for ID in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[ID]
			mylb = 0.0
			myub = float(self.VMAX)
			metlist = []
			coeflist = [] 
			coeflistRev = []
			for reactant in equation[0]:
				species, coef = reactant[0], '-' + str(reactant[1])
				if '_b' == species[-2:]:
					continue
				metlist.append(constraints[species])
				# for the yaml business
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				coeflist.append(float(coef))
				coeflistRev.append(0.0-float(coef))
			for product in equation[1]:
				species, coef = product[0], product[1]
				if '_b' == species[-2:]:
					continue
				metlist.append(constraints[species])
				# for the yaml business
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				coeflist.append(float(coef))
				coeflistRev.append(0.0-float(coef))
			variables[ID] = gurobiprob.addVar(lb=mylb, ub=myub, obj=0.0, name = ID, column= Column(coeflist, metlist))
			if bool(reversible) == True:
				variables[ID+"_r"] = gurobiprob.addVar(lb=mylb, ub=myub, obj=0.0, name = ID + "_r", column= Column(coeflistRev, metlist))
		gurobiprob.update()
	def writeSparseS(self,gurobiprob, variables, constraints, outfname):
		outfile=open (outfname, "w")
		varkeys = variables.keys()
		conkeys = constraints.keys()
		varkeys.sort()
		conkeys.sort()
		numreactions = 0
		myvarlist = []
		for j, var in enumerate(varkeys):
			if "EXCH" not in var:
				if var == "R_biomass_target":
					biomassindex = numreactions
				myvarlist.append(var)
				numreactions += 1
				if variables[var].lb < -0.01:
					myvarlist.append(var+"_r")
					numreactions += 1
		for exchange, lb, ub in self.EXCHANGES:
			if float(ub) > 0.0:		
				myvarlist.append("R_ESC_"+exchange[2:])
				numreactions += 1
			if float(lb) < 0.0:
				myvarlist.append("R_SRC_"+exchange[2:])
				numreactions += 1
						
			# add exchange reactions
		outfile.write("%d,%d,%d\n" % (biomassindex, numreactions, len(conkeys)+2))
		for i, var in enumerate(myvarlist):
			outfile.write("%d,%s\n" % (i, var.replace(",","")))
		for i, con in enumerate(conkeys):
			outfile.write("%d,%s\n" % (i, con.replace(",","")))
		outfile.write("%d,s\n" % len(conkeys))
		outfile.write("%d,e\n" % (len(conkeys)+1))
		numreactions = 0
		for j, var in enumerate(varkeys):
			if 'EXCH' not in var:
				for i, con in enumerate(conkeys):
					if gurobiprob.getCoeff(constraints[con], variables[var]) != 0.0:
						outfile.write("%d,%d,%f\n" % (i,myvarlist.index(var), gurobiprob.getCoeff(constraints[con], variables[var])))
						#outfile.write("%s,%s,%f\n" % (con,var, gurobiprob.getCoeff(constraints[con], variables[var])))
				if variables[var].lb < -0.01:
					numreactions += 1
					for i, con in enumerate(conkeys):
		 				if gurobiprob.getCoeff(constraints[con], variables[var]) != 0.0:
		 					outfile.write("%d,%d,%f\n" % (i,myvarlist.index(var+"_r"), -gurobiprob.getCoeff(constraints[con], variables[var])))
		 					#outfile.write("%s,%s,%f\n" % (con,var+"_r", -gurobiprob.getCoeff(constraints[con], variables[var])))
				numreactions += 1
		for source in self.SOURCES:
			outfile.write("%d,%d,-1\n" % (len(conkeys), myvarlist.index("R_SRC_"+source[2:]))) 
			outfile.write("%d,%d,1\n" % (conkeys.index(source), myvarlist.index("R_SRC_"+source[2:]))) 
			#outfile.write("s,%s,-1\n" % ("R_SRC_"+source[2:])) 
			#outfile.write("%s,%s,1\n" % (source, "R_SRC_"+source[2:])) 
		for escape in self.ESCAPES:
			outfile.write("%d,%d,1\n" % (len(conkeys)+1, myvarlist.index("R_ESC_"+escape[2:]))) 
			outfile.write("%d,%d,-1\n" % (conkeys.index(escape), myvarlist.index("R_ESC_"+escape[2:]))) 
			#outfile.write("e,%s,1\n" % ("R_ESC_"+escape[2:])) 
			#outfile.write("%s,%s,-1\n" % (escape, "R_ESC_"+escape[2:])) 
		for exchange, lb, ub in self.EXCHANGES:
			if float(ub) > 0.0:		
				outfile.write("%d,%d,-1\n" % (conkeys.index(exchange), myvarlist.index("R_ESC_"+exchange[2:]))) 
				outfile.write("%d,%d,1\n" % (len(conkeys)+1, myvarlist.index("R_ESC_"+exchange[2:]))) 
			if float(lb) < 0.0:
				outfile.write("%d,%d,-1\n" % (len(conkeys), myvarlist.index("R_SRC_"+exchange[2:]))) 
				outfile.write("%d,%d,1\n" % (conkeys.index(exchange), myvarlist.index("R_SRC_"+exchange[2:]))) 
		outfile.close()


	def populategap (self, gurobiprob, minbiomass, sCost, eCost, notSources, notEscapes, variables, constraints):
		#calculate cost
		gurobicb.gapcost(self, sCost, eCost, notSources, notEscapes)
		# add source indicator variables and flux variables
		for met in sCost.keys():
			if '_b' == met[-2:]:
				continue
			variables["_s_" + met] = gurobiprob.addVar(obj=sCost[met], name="_s_"+met, vtype=GRB.BINARY)
			variables["_src_" + met] = gurobiprob.addVar(lb=0.0, obj=0.0, name="_src_" + met, column=Column([1.0],[constraints[met]]))
		# add escape indicator variables and flux variables
		for met in eCost.keys():
			if '_b' == met[-2:]:
				continue
			variables["_e_" + met] = gurobiprob.addVar(obj=eCost[met], name="_e_"+met, vtype=GRB.BINARY)
			variables["_esc_" + met] = gurobiprob.addVar(lb=0.0, obj=0.0, name="_esc_" + met, column=Column([-1.0],[constraints[met]]))
		gurobiprob.update()
		# add source and escape indicator constraints
		for met in sCost.keys():
			if '_b' == met[-2:]:
				continue
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables["_src_" + met], variables["_s_"+met]]), sense=GRB.LESS_EQUAL, rhs = 0.0) 
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables["_esc_" + met], variables["_e_"+met]]), sense=GRB.LESS_EQUAL, rhs = 0.0) 
		for met in eCost.keys():
			if '_b' == met[-2:]:
				continue
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables["_src_" + met], variables["_s_"+met]]), sense=GRB.LESS_EQUAL, rhs = 0.0) 
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables["_esc_" + met], variables["_e_"+met]]), sense=GRB.LESS_EQUAL, rhs = 0.0) 
		# add min biomass constraint
		gurobiprob.addConstr(lhs=LinExpr([1.0], [variables["R_biomass_target"]]), rhs=minbiomass, sense=GRB.GREATER_EQUAL, name="minbiomass")
		# change bounds for known not sources
		#notSources.append('M_atp_c')
		#notSources.append('M_fdp_c')
		#notSources.append('M_g6p_c')
		#notEscapes.append('M_prpp_c')
		for src in notSources:
			try:
				variables["_s_"+src].setAttr("UB", 0.0)
			except:
				if src[-2:] != '_b':
					print src, " not in metabolites"
		# change bounds for known not escapes
		for esc in notEscapes:
			try:
				variables["_e_"+esc].setAttr("UB", 0.0)
			except:
				if esc[-2:] != '_b':
					print esc, " not in metabolites"
		gurobiprob.update()
	def gapcost (self, sCost, eCost, notSources, notEscapes):
		sDistance = {}
		eDistance = {}
		Smatrix = {}
		reactionCount = {} 
		try:  # for Python >= 2.5
		        reactionsConsumed = defaultdict(list) 
		        reactionsProduced = defaultdict(list) 
		        reactionsRevReactant = defaultdict(list)
		        reactionsRevProduct = defaultdict(list)
		except:
		        reactionsConsumed    = {} 
		        reactionsProduced    = {} 
		        reactionsRevReactant = {}
		        reactionsRevProduct  = {}
		for met in self.SPECIES:
			sDistance[met] = 100000.0
			eDistance[met] = 100000.0
			reactionCount[met] = 0
			reactionsConsumed[met] = []  # this line and the next 3 needed for Python < 2.5
			reactionsProduced[met]    = [] 
			reactionsRevReactant[met] = [] 
			reactionsRevProduct[met]  = [] 
		# get reaction count for each metabolite
		for reaction in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[reaction]
			for met in equation[0]:	
				reactionCount[met[0]] += 1
				if reversible == True:
					try: #Python >= 2.5
						reactionsRevReactant[met[0]].append(reaction)
					except:
						reactionsRevReactant.setdefault(met[0],[]).append(reaction)
				else:
					try: #Python >= 2.5
						reactionsConsumed[met[0]].append(reaction)
					except:
						reactionsConsumed.setdefault(met[0],[]).append(reaction)
			for met in equation[1]:	
				reactionCount[met[0]] += 1
				if reversible == True:
					try: #Python >= 2.5
						reactionsRevProduct[met[0]].append(reaction)
					except:
						reactionsRevProduct.setdefault(met[0],[]).append(reaction)
				else:
					try: #Python >= 2.5
						reactionsProduced[met[0]].append(reaction)
					except:
						reactionsProduced.setdefault(met[0],[]).append(reaction)
		lnu = [] # labeled and unscanned
		name, reversible, notes, equation = self.REACTIONS["R_biomass_target"]
		for met in equation[0]:	
			lnu.append(met[0])
			sDistance[met[0]] = 0.0
		while len(lnu) != 0:
			toScan = lnu.pop(0)
			#find reactions where toScan is produced, find a metabolite on the other side and update distance or label
			for reaction in reactionsProduced[toScan]:
				name, reversible, notes, equation = self.REACTIONS[reaction]
				for met in equation[0]:
					if sDistance[met[0]] == 100000.0:
						lnu.append(met[0])
					if sDistance[met[0]] > sDistance[toScan] + reactionCount[toScan]:
						sDistance[met[0]] = sDistance[toScan] + reactionCount[toScan]
			for reaction in reactionsRevReactant[toScan]:
				name, reversible, notes, equation = self.REACTIONS[reaction]
				for met in equation[1]:
					if sDistance[met[0]] == 100000.0:
						lnu.append(met[0])
					if sDistance[met[0]] > sDistance[toScan] + reactionCount[toScan]:
						sDistance[met[0]] = sDistance[toScan] + reactionCount[toScan]
			for reaction in reactionsRevProduct[toScan]:
				name, reversible, notes, equation = self.REACTIONS[reaction]
				for met in equation[0]:
					if sDistance[met[0]] == 100000.0:
						lnu.append(met[0])
					if sDistance[met[0]] > sDistance[toScan] + reactionCount[toScan]:
						sDistance[met[0]] = sDistance[toScan] + reactionCount[toScan]
		lnu = [] # labeled and unscanned
		name, reversible, notes, equation = self.REACTIONS["R_biomass_target"]
		for met in equation[1]:	
			lnu.append(met[0])
			eDistance[met[0]] = 0.0
		while len(lnu) != 0:
			toScan = lnu.pop(0)
			#find reactions where toScan is consumed, find a metabolite on the other side and update distance or label
			for reaction in reactionsConsumed[toScan]:
				name, reversible, notes, equation = self.REACTIONS[reaction]
				for met in equation[1]:
					if eDistance[met[0]] == 100000.0:
						lnu.append(met[0])
					if eDistance[met[0]] > eDistance[toScan] + reactionCount[toScan]:
						eDistance[met[0]] = eDistance[toScan] + reactionCount[toScan]
			for reaction in reactionsRevReactant[toScan]:
				name, reversible, notes, equation = self.REACTIONS[reaction]
				for met in equation[1]:
					if eDistance[met[0]] == 100000.0:
						lnu.append(met[0])
					if eDistance[met[0]] > eDistance[toScan] + reactionCount[toScan]:
						eDistance[met[0]] = eDistance[toScan] + reactionCount[toScan]
			for reaction in reactionsRevProduct[toScan]:
				name, reversible, notes, equation = self.REACTIONS[reaction]
				for met in equation[0]:
					if eDistance[met[0]] == 100000.0:
						lnu.append(met[0])
					if eDistance[met[0]] > eDistance[toScan] + reactionCount[toScan]:
						eDistance[met[0]] = eDistance[toScan] + reactionCount[toScan]
		# find max sDistance, eDistance
		maxSdist = 0.0
		maxEdist = 0.0
		for met in self.SPECIES:
			if (maxSdist < sDistance[met]) & (sDistance[met] != 100000.0):	
				maxSdist = sDistance[met]
			elif sDistance[met] == 100000.0:
				notSources.append(met)
			if (maxEdist < eDistance[met]) & (eDistance[met] != 100000.0):	
				maxEdist = eDistance[met]
			elif eDistance[met] == 100000.0:
				notEscapes.append(met)
		#assign costs
		lowCostSources = []
		lowCostEscapes = []
		gurobicb.readLowCostMetabolites (self, lowCostSources, lowCostEscapes)
		for met in self.SPECIES:
			if met in lowCostSources:
				sCost[met] = 1.0
			elif met.endswith("_e"):
				sCost[met] = 20.0
			else:
				sCost[met] = 100.0 * (maxSdist - sDistance[met] + 1.0)
			if met in lowCostEscapes:
				eCost[met] = 1.0
			elif met.endswith("_e"):
				eCost[met] = 20.0
			else:
				eCost[met] = 100.0 * (maxEdist - eDistance[met] + 1.0)
	def readLowCostMetabolites (self, lowCostSources, lowCostEscapes):
		lowCostFile = open("/usr/local/lib/site-packages/LowCostMetabolites.txt", "r")
		for line in lowCostFile.readlines():
			if line[0] == '#':
				continue
			else:
				line1 = line.split('\t')	
				met = line1[0]
				#met = eq_current.convert_metabolite_ext2int(line1[0])
				if self.metPalsson2KeggID.has_key(met[:-3].lower()):
					met = "M_"+self.metPalsson2KeggID[met[:-3].lower()]+"_"+met[-2:-2]
				elif self.metSeedNames2KeggID.has_key(met[:-3].lower()):
					met = "M_"+self.metSeedNames2KeggID[met[:-3].lower()]+"_"+met[-2:-2]
				else:
					print met[:-3], "in LowCostMetabolites but not in MetaboliteDB"
				if len(line1) >= 4:
					if "y" in line1[3]:
						lowCostSources.append(met)
				if len(line1) >= 5:
					if "y" in line1[4]:
						lowCostEscapes.append(met)
	def readReactionDB (self):
		rxnDbFile = open("/usr/local/lib/site-packages/rxnDb.txt", "r")
		lines = csv.reader(rxnDbFile, delimiter='\t')
		for line in lines:
			if 'SEED ID' not in line:
				if line[0] != ".":
					self.rxnSeedDB["R_"+line[0]] = line
				if line[6] != ".":
					self.rxnPalssonDB[line[6]] = line
				if line[12] != ".":
					self.rxnPalssonDB[line[12]] = line
				if line[18] != ".":
					self.rxnTransportDB[line[18]] = line
				if line[1] != ".":
					self.rxnByKeggID["R_"+line[1]] = line

	def readMetaboliteDB (self):
		seedMetFile = open("/usr/local/lib/site-packages/compound_database_v2.txt", "r")
		lines = csv.reader(seedMetFile, delimiter='\t')
		for line in lines:
			if 'DATABASE' not in line:
				if line[4] != "":
					keggID = line[4]
					if "|" in line[4]: # take first KEGG ID
						keggID = line[4].split("|")[0]
					self.metKeggIDs.add(keggID.lower())
					self.metSeed2KeggID[line[0].lower()] = keggID
					self.metPalsson2KeggID[line[2].lower()] = keggID
					if not self.metKeggID2Palsson.has_key(keggID):
						self.metKeggID2Palsson[keggID] = line[2].lower()
					if "|" in line[3]: # multiple names
						seedNames = line[3].split("|")
						for name in seedNames:
							self.metSeedNames2KeggID[name.replace(" ", "_").lower()] = keggID
					else:
						self.metSeedNames2KeggID[line[3].replace(" ", "_").lower()] = keggID
		
	def addreactionsdb (self, gurobiprob, dbreactions, variables):
		# populate dbreactions
		# if not in model, add _r_ variable, add reaction so that mass balance can be added with populateSv
		# populate self.EQUATIONS?  #self.EQUATIONS[stringequation] = id
		for reaction in self.rxnSeedDB:
			rxnInfo = self.rxnSeedDB[reaction]
			if (reaction not in self.REACTIONS) and (rxnInfo[6] not in self.REACTIONS) and (rxnInfo[12] not in self.REACTIONS) and (rxnInfo[18] not in self.REACTIONS) and (rxnInfo[1] not in self.REACTIONS):
				if rxnInfo[3] != ' <=> ' and not rxnInfo[3].startswith(' =>'):
					rev, equation = eq_current.parse(rxnInfo[3])
					dbreactions[reaction] = (rxnInfo[5], rxnInfo[4], {}, equation)
					gurobicb.add_reaction(self, reaction, rxnInfo[5], rxnInfo[4], {}, equation) # id, name, reversibility, notes, equation
					variables["_r_" + reaction] = gurobiprob.addVar(obj=1.0, name="_r_"+reaction, vtype=GRB.BINARY)
		for reaction in self.rxnPalssonDB:
			rxnInfo = self.rxnPalssonDB[reaction]
			if (rxnInfo[0] not in self.REACTIONS) and (rxnInfo[6] not in self.REACTIONS) and (rxnInfo[12] not in self.REACTIONS) and (rxnInfo[18] not in self.REACTIONS) and (rxnInfo[1] not in self.REACTIONS):
				if rxnInfo[10] != ".": # use Niti's equation if possible
					rev, equation = eq_current.parse(rxnInfo[10])
					gurobicb.add_reaction(self, reaction, rxnInfo[11], rxnInfo[7], {}, equation) # id, name, reversibility, notes, equation
					dbreactions[reaction] = (rxnInfo[11], rxnInfo[7], {}, rxnInfo[10])
				else:
					rev, equation = eq_current.parse(rxnInfo[16])
					gurobicb.add_reaction(self, reaction, rxnInfo[17], rxnInfo[13], {}, equation) # id, name, reversibility, notes, equation
					dbreactions[reaction] = (rxnInfo[17], rxnInfo[13], {}, rxnInfo[16])
				variables["_r_" + reaction] = gurobiprob.addVar(obj=1.0, name="_r_"+reaction, vtype=GRB.BINARY)
		for reaction in self.rxnTransportDB:
			rxnInfo = self.rxnTransportDB[reaction]
			if (rxnInfo[0] not in self.REACTIONS) and (rxnInfo[6] not in self.REACTIONS) and (rxnInfo[12] not in self.REACTIONS) and (rxnInfo[18] not in self.REACTIONS) and (rxnInfo[1] not in self.REACTIONS):
				rev, equation = eq_current.parse(rxnInfo[21])
				gurobicb.add_reaction(self, reaction, rxnInfo[22], rxnInfo[19], {}, equation) # id, name, reversibility, notes, equation
				dbreactions[reaction] = (rxnInfo[22], rxnInfo[19], {}, rxnInfo[21])
				variables["_r_" + reaction] = gurobiprob.addVar(obj=1.0, name="_r_"+reaction, vtype=GRB.BINARY)
		
	def addDBConstraints (self, gurobiprob, dbreactions, variables, constraints):
		for reaction in dbreactions:
                        # ensure cost of adding reaction
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables[reaction], variables["_r_" + reaction]]), sense=GRB.LESS_EQUAL, rhs=0.0)  
			gurobiprob.addConstr(lhs=LinExpr([1.0, float(self.VMAX)], [variables[reaction], variables["_r_" + reaction]]), sense=GRB.GREATER_EQUAL, rhs=0.0)  
		gurobiprob.update()
		# add variables and constraints for reversible reactions
		#for equation in self.EQUATIONS.keys():
		#	if "-->" in equation:
		#		reveq = equation.replace("-->", "<==>")
		#		if reveq in self.EQUATIONS.keys():
		#			id = self.EQUATIONS[equation]
		#			revid = self.EQUATIONS[reveq]
		#			# add indicator variables and "flip on" constraints if reactions are already in the model
		#			if "_r_"+id not in variables.keys():
		#				variables["_r_"+id] = gurobiprob.addVar(obj=0.0, name="_r_"+id, vtype=GRB.BINARY)
		#				gurobiprob.update()
		#				gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables[id], variables["_r_"+id]]), sense=GRB.LESS_EQUAL, rhs=0.0)  
		#				gurobiprob.update()
		#			if "_r_"+revid not in variables.keys():
		#				variables["_r_"+revid] = gurobiprob.addVar(obj=0.0, name="_r_"+revid, vtype=GRB.BINARY)
		#				gurobiprob.update()
		#				gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables[revid], variables["_r_"+revid]]), sense=GRB.LESS_EQUAL, rhs=0.0)  
		#				gurobiprob.addConstr(lhs=LinExpr([1.0, float(self.VMAX)], [variables[revid], variables["_r_"+revid]]), sense=GRB.GREATER_EQUAL, rhs=0.0)  
		#				gurobiprob.update()
		#			# add constraint that they both can't be 1
		#			gurobiprob.addConstr(lhs=LinExpr([1.0, 1.0], [variables["_r_"+id], variables["_r_"+revid]]), sense=GRB.LESS_EQUAL, rhs=1.0)  
		#gurobiprob.update()
		
	def populateGapFind (self, gurobiprob, eightlist, variables, constraints):
		# constraints (10), (11), (12)
		for species in self.SPECIES:
			if self.SPECIES[species]["compartment"] == "Cytosol":
				constraints[species] = gurobiprob.addConstr(lhs=0.0, sense=GRB.GREATER_EQUAL, rhs=0.0, name=species)	
			else:
				constraints[species] = gurobiprob.addConstr(lhs=0.0, sense=GRB.EQUAL, rhs=0.0, name=species)	
		gurobiprob.update()
		#add columns
		for ID in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[ID]
			#if there have been specific constraints already set, use them...
			if ID in self.CONSTRAINTS:
				mylb, myub = self.CONSTRAINTS[ID]
				mylb = float(mylb)
				myub = float(myub)
			#otherwise create constraints on the fly, using reaction reversibility and self.VMAX...
			else:
				myub = float(self.VMAX)
				if bool(reversible):
					mylb = 0.0 - float(self.VMAX)
				else:
					mylb = 0.0
			metlist = []
			coeflist = [] 
			for reactant in equation[0]:
				species, coef = reactant[0], '-' + str(reactant[1])
				if '_b' == species[-2:]:
					continue
				metlist.append(constraints[species])
				# for the yaml business
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				coeflist.append(float(coef))
				
			for product in equation[1]:
				species, coef = product[0], product[1]
				if '_b' == species[-2:]:
					continue
				metlist.append(constraints[species])
				# for the yaml business
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				coeflist.append(float(coef))
			variables[ID] = gurobiprob.addVar(lb=mylb, ub=myub, obj=0.0, name=ID, column=Column(coeflist, metlist))
		gurobiprob.update()
		# add x_i variables
		bigM = float(self.VMAX)
		epsilon = 0.001
		for ID in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[ID]
			if reversible == False:
				for product in equation[1]:
					species = product[0]
					if species not in eightlist:
						eightlist.append(species)
						variables[species+"_x8"] = gurobiprob.addVar(obj=1.0, name=species+"_x8", vtype=GRB.BINARY)
			else:
				for reactant in equation[0]:
					species = reactant[0]
					if species not in eightlist:
						eightlist.append(species)
						variables[species+"_x8"] = gurobiprob.addVar(obj=1.0, name=species+"_x8", vtype=GRB.BINARY)
				for product in equation[1]:
					species = product[0]
					if species not in eightlist:
						eightlist.append(species)
						variables[species+"_x8"] = gurobiprob.addVar(obj=1.0, name=species+"_x8", vtype=GRB.BINARY)
		gurobiprob.update()
		# add constraints (8)
		for species in eightlist:
			constraints[species+"_8"] = gurobiprob.addConstr(rhs=0.0, sense=GRB.GREATER_EQUAL, name=species+"_8", lhs=LinExpr([-1.0],[variables[species+"_x8"]]))
		gurobiprob.update()
		# add w_ij variables
		for ID in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[ID]
			if reversible == False:
				for product in equation[1]:
					species = product[0]
					variables[ID+species] = gurobiprob.addVar(obj=0.0, lb=0.0, ub=1.0, name=ID+species, vtype=GRB.BINARY, column=Column([1.0],[constraints[species+"_8"]])) 
			else:
				for reactant in equation[0]:
					species = reactant[0]
					variables[ID+species] = gurobiprob.addVar(obj=0.0, lb=0.0, ub=1.0, name=ID+species, vtype=GRB.BINARY, column=Column([1.0],[constraints[species+"_8"]]))
				for product in equation[1]:
					species = product[0]
					variables[ID+species] = gurobiprob.addVar(obj=0.0, lb=0.0, ub=1.0, name=ID+species, vtype=GRB.BINARY, column=Column([1.0],[constraints[species+"_8"]]))
		gurobiprob.update()
		# constraints (4)-(9), add w_ij variables
		for ID in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[ID]
			if reversible == False:
				for product in equation[1]:
					species, coef = product[0], product[1]
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					gurobiprob.addConstr(rhs=0.0, sense=GRB.GREATER_EQUAL, lhs=LinExpr([float(coef), -epsilon],[variables[ID], variables[ID+species]]))
					gurobiprob.addConstr(rhs=0.0, sense=GRB.LESS_EQUAL, lhs=LinExpr([float(coef), -bigM],[variables[ID], variables[ID+species]]))
			else:
				for reactant in equation[0]:
					species, coef = reactant[0], '-' + str(reactant[1])
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					gurobiprob.addConstr(rhs=epsilon-bigM, sense=GRB.GREATER_EQUAL, lhs=LinExpr([float(coef), -bigM],[variables[ID], variables[ID+species]]))
					gurobiprob.addConstr(rhs=0.0, sense=GRB.LESS_EQUAL, lhs=LinExpr([float(coef), -bigM],[variables[ID], variables[ID+species]]))
				for product in equation[1]:
					species, coef = product[0], product[1]
					# for the yaml business
					if '-n' in str(coef):
						coef = -1.0
					elif 'n' in str(coef):
						coef = 1.0
					gurobiprob.addConstr(rhs=epsilon-bigM, sense=GRB.GREATER_EQUAL, lhs=LinExpr([float(coef), -bigM],[variables[ID], variables[ID+species]]))
					gurobiprob.addConstr(rhs=0.0, sense=GRB.LESS_EQUAL, lhs=LinExpr([float(coef), -bigM],[variables[ID], variables[ID+species]]))
		gurobiprob.update()
		for variable in variables:
			variables[variable].Start = 0.0
		gurobiprob.update()
	def populateGapFill (self, metabolite, gurobiprob, variables, constraints, dbreactions):
		# add db reactions, gamma variables
		reactiondbFile = open("reactions.txt", "r")
		for line in reactiondbFile.readlines():
			line1 = line.split("\t")
			[pathwaysstr, ecsstr, id, rev, name, stringequation] = line1[0:6]
			if id not in self.REACTIONS.keys():
				#dbreactions.append(id)
				reversibility, equation = eq_current.parse(stringequation)
				notes, pathways, ecs = {}, pathwaysstr.split(';'), ecsstr.split(';')
				dbreactions[id] = (name, reversibility, notes, equation)
				gurobicb.add_reaction(self, id, name, reversibility, notes, equation)
				variables["_g_"+id] = gurobiprob.addVar(obj=1.0, name="_g_"+id, vtype=GRB.BINARY)
		gurobiprob.update()
		# constraints (17), (11), (12) add w variables
		wreactions = []
		wreactionvars = []
		for species in self.SPECIES:
			if self.SPECIES[species]["compartment"] == "Cytosol":
				constraints[species] = gurobiprob.addConstr(lhs=0.0, sense=GRB.GREATER_EQUAL, rhs=0.0, name=species)	
			else:
				constraints[species] = gurobiprob.addConstr(lhs=0.0, sense=GRB.EQUAL, rhs=0.0, name=species)	
		gurobiprob.update()
		#add columns
		for ID in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[ID]
			#if there have been specific constraints already set, use them...
			if ID in self.CONSTRAINTS:
				mylb, myub = self.CONSTRAINTS[ID]
				mylb = float(mylb)
				myub = float(myub)
			#otherwise create constraints on the fly, using reaction reversibility and self.VMAX...
			else:
				myub = float(self.VMAX)
				if bool(reversible):
					mylb = 0.0 - float(self.VMAX)
				else:
					mylb = 0.0
			metlist = []
			coeflist = [] 
			for reactant in equation[0]:
				species, coef = reactant[0], '-' + str(reactant[1])
				if '_b' == species[-2:]:
					continue
				metlist.append(constraints[species])
				# for the yaml business
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				coeflist.append(float(coef))
				if metabolite == species:
					variables["_w_"+ID] = gurobiprob.addVar(name="_w_"+ID, obj=0.0, vtype=GRB.BINARY)
					wreactionvars.append(variables["_w_"+ID])
					wreactions.append((ID,float(coef)))
				
			for product in equation[1]:
				species, coef = product[0], product[1]
				if '_b' == species[-2:]:
					continue
				metlist.append(constraints[species])
				# for the yaml business
				if '-n' in str(coef):
					coef = -1.0
				elif 'n' in str(coef):
					coef = 1.0
				coeflist.append(float(coef))
				if metabolite == species:
					variables["_w_"+ID] = gurobiprob.addVar(name="_w_"+ID, obj=0.0, vtype=GRB.BINARY)
					wreactionvars.append(variables["_w_"+ID])
					wreactions.append((ID,float(coef)))
			variables[ID] = gurobiprob.addVar(lb=mylb, ub=myub, obj=0.0, name=ID, column=Column(coeflist, metlist))
		gurobiprob.update()
		# add constraints (19)
		for id in dbreactions:
			name, reversible, notes, equation = self.REACTIONS[id]
			myub = float(self.VMAX)
			gurobiprob.addConstr(lhs=LinExpr([1.0,-myub], [variables[id], variables["_g_"+id]]), sense=GRB.LESS_EQUAL, rhs=0.0)
			if bool(reversible):
				mylb = 0.0 - float(self.VMAX)
				gurobiprob.addConstr(lhs=LinExpr([-1.0,mylb], [variables[id], variables["_g_"+id]]), sense=GRB.LESS_EQUAL, rhs=0.0)
		gurobiprob.update()
		# add constraints (14), (15)
		delta = 1.0
		M = float(self.VMAX)
		for id, coef in wreactions:
			# rhs = delta - M, delta = 1 as in gapfill.gms
			gurobiprob.addConstr(lhs=LinExpr([coef, -M], [variables[id], variables["_w_"+ id]]), sense=GRB.GREATER_EQUAL, rhs=delta-M) 
			gurobiprob.addConstr(lhs=LinExpr([coef, -M], [variables[id], variables["_w_"+ id]]), sense=GRB.LESS_EQUAL, rhs=0.0) 
		# add constraints (16)
		ones = [1.0]
		ones *= len(wreactionvars)
		gurobiprob.addConstr(lhs=LinExpr(ones, wreactionvars), sense=GRB.GREATER_EQUAL, rhs=1.0) 
		gurobiprob.update()
		#delete database reactions from model
		for reaction in dbreactions:
			gurobicb.delete_reaction(self, reaction)
		del wreactions
		del wreactionvars
		del metlist
		del coeflist
		del equation 
		del ones
	def populateGapReed (self, gurobiprob, minbiomass, variables, constraints):
		# add source and escape fluxes 
		for met in self.SPECIES.keys():
			if '_b' == met[-2:]:
				continue
			variables["_src_" + met] = gurobiprob.addVar(lb=0.0, obj=0.0, name="_src_" + met, column=Column([1.0],[constraints[met]]))
			variables["_esc_" + met] = gurobiprob.addVar(lb=0.0, obj=0.0, name="_esc_" + met, column=Column([-1.0],[constraints[met]]))
		# add source indicator variables
		for met in self.SPECIES.keys():
			if '_b' == met[-2:]:
				continue
			variables["_s_" + met] = gurobiprob.addVar(obj=1.0, name="_s_"+met, vtype=GRB.BINARY)
		# add escape indicator variables
		for met in self.SPECIES.keys():
			if '_b' == met[-2:]:
				continue
			variables["_e_" + met] = gurobiprob.addVar(obj=1.0, name="_e_"+met, vtype=GRB.BINARY)
		gurobiprob.update()
		# add source and escape indicator constraints
		for met in self.SPECIES.keys():
			if '_b' == met[-2:]:
				continue
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables["_src_" + met], variables["_s_"+met]]), sense=GRB.LESS_EQUAL, rhs = 0.0) 
			gurobiprob.addConstr(lhs=LinExpr([1.0, -float(self.VMAX)], [variables["_esc_" + met], variables["_e_"+met]]), sense=GRB.LESS_EQUAL, rhs = 0.0) 
		# add min biomass constraint
		gurobiprob.addConstr(lhs=LinExpr([1.0], [variables["R_biomass_target"]]), rhs=minbiomass, sense=GRB.GREATER_EQUAL, name="minbiomass")
		gurobiprob.update()

	def getActiveReactions (self, activereactions, maxbiomass, fixedRxnsFluxes, epsilon = 0.00001): 
		# set each reaction to biomass, and see if nonzero flux is possible
		numFixedRxns = 0
		#notFixedFile = open("tcruziNotFixedFile.txt", "w") # for getting reactions not fixed for T. cruzi
		for index, reaction in enumerate(self.REACTIONS): 
			if "biomass_temp" not in reaction:
				sys.stdout.write("%d %s " % (index, reaction))
				sys.stdout.flush()
				name, reversible, notes, equation = self.REACTIONS[reaction] 
				self.delete_reaction(reaction)
				gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, equation) # make it the biomass reaction; note it is not reversible
				self.solveActiveReactionsLP(epsilon, maxbiomass)
				#if self.STATUS == 2:
				#	print reaction, self.OBJECTIVE_VALUE
				if (self.STATUS == 3) or (self.OBJECTIVE_VALUE > epsilon): # if it's infeasible, then the reverse reaction must be necessary
					activereactions.append(deepcopy(reaction))
				elif bool(reversible): # if reversible, solve with opposite direction as biomass
					self.delete_reaction("R_biomass_target")
					gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", False, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, [equation[1],equation[0]]) 	
					self.solveActiveReactionsLP(epsilon,maxbiomass)
					if self.OBJECTIVE_VALUE > epsilon:
						activereactions.append(reaction)
				# check if reaction has a fixed flux
				self.delete_reaction("R_biomass_target")
					# add reaction as biomass, and maintain reversibility
				gurobicb.add_reaction(self, "R_biomass_target", "BiomassRxn", reversible, {'SUBSYSTEM: BiomassObjective':1, 'EC: .':1}, equation) # make it the biomass reaction
				self.solveActiveReactionsLP(epsilon, maxbiomass)
				if self.STATUS == 2:
					maxobj = self.OBJECTIVE_VALUE
					self.solveActiveReactionsLP(epsilon, maxbiomass, "min")
					minobj = self.OBJECTIVE_VALUE
					if (abs(maxobj - minobj) < epsilon) and (abs(maxobj) > epsilon):
						numFixedRxns += 1
						fixedRxnsFluxes[reaction] = maxobj
					#elif abs(maxobj - minobj) >= epsilon:
					#	notFixedFile.write("%s %.12f %.12f\n" % (reaction, minobj, maxobj))	
				self.delete_reaction("R_biomass_target")
				gurobicb.add_reaction(self, reaction, name, reversible, notes, equation)
		#notFixedFile.close()
		print "Num Fixed ", numFixedRxns
	def solveActiveReactionsLP (self, epsilon, maxbiomass, objsense = "max"):
  		# define and populate model 
		gurobiprob = Model("ActiveR")
		gurobiprob.ModelSense = -1 
		if objsense == "min":
			gurobiprob.ModelSense = 1 
		variables = {}
		constraints = {}
		handle = gurobicb.populateSv(self, gurobiprob, variables, constraints)
		#set biomass coefficient to 1.0
		variables["R_biomass_target"].setAttr("Obj", 1.0)
		gurobiprob.Params.OutputFlag = 0
		gurobiprob.Params.FeasibilityTol = 1e-9
		gurobiprob.Params.OptimalityTol = 1e-9
		gurobiprob.update()
                # add constraint on min biomass
		variables["biomass_temp"].LB = maxbiomass
		gurobiprob.update()
		gurobiprob.optimize()
		self.STATUS = gurobiprob.Status
		if self.STATUS == 2:
			self.OBJECTIVE_VALUE = gurobiprob.ObjVal
			
	def writeWil(self, filename=None):
		if filename==None:
			filename = self.MODEL_ID + ".wil"
		wilfile = open(filename, "w")
		wilfile.write("Biomass Equation\n")
		name, reversible, notes, equation = self.REACTIONS["R_biomass_target"]
		wilfile.write("%s" % (eq_current.makestring(equation, reversible)))
		wilfile.write("\n\nReactions\n")
		mysc = "; "
		for reaction in self.REACTIONS:
			if "R_SRC_" not in reaction and "R_ESC_" not in reaction and "R_EXCH_" not in reaction and "R_biomass_target" not in reaction:
				cache = {}
				name, reversible, notes, equation = self.REACTIONS[reaction]
				pathways = 0
				ecs = 0
				for notekey in  notes.keys():
					if 'SUBSYSTEM' in notekey:
						pathways = 1
					if 'EC' in notekey:
						ecs = 1
				if pathways == 0:
					notes['SUBSYSTEM: .'] = 1
				if ecs == 0:
					notes['EC: .'] = 1
				if reaction[:2] == 'R_':
					self.REACTIONS[reaction] = (name, reversible, notes, equation)
				else:
					gurobicb.delete_reaction(self, reaction)
					self.REACTIONS['R_' + reaction] = (name, reversible, notes, equation)
				pathways = []
				ecs = []
				for note in notes:
					if 'SUBSYSTEM: ' in note:
						pathways.append(note[11:])
					if 'EC: ' in note:
						ecs.append(note[4:])
				if reaction[:2] == 'R_':
					wilfile.write("%s\t%s\t%s\t%s\t%s\t%s\tnull\tnull\tnull\n" % (mysc.join(pathways), mysc.join(ecs), reaction, str(reversible), name, eq_current.makestring(equation, reversible)))	
				else:
					wilfile.write("%s\t%s\t%s\t%s\t%s\t%s\tnull\tnull\tnull\n" % (mysc.join(pathways), mysc.join(ecs), "R_" + reaction, str(reversible), name, eq_current.makestring(equation, reversible)))	
		wilfile.write("\nSources\n")
		for source in self.SOURCES:
			wilfile.write("%s\n" % metabolite.convert_int2ext(source))
		for (species, lb, ub) in self.EXCHANGES:
			if float(lb) < 0.0:
				wilfile.write("%s\n" % metabolite.convert_int2ext(species))
		wilfile.write("\nEscapes\n")
		for escape in self.ESCAPES:
			wilfile.write("%s\n" % metabolite.convert_int2ext(escape))
		for (species, lb, ub) in self.EXCHANGES:
			if float(ub) > 0.0:
				wilfile.write("%s\n" % metabolite.convert_int2ext(species))
		wilfile.write("\nGenes\n")
	def writeECfile(self, out = ""):
		if out == "":
			ecfile = open(self.MODEL_ID+"ec1.txt", "w")
		else:
			ecfile = open(out, "w")
		ecs = set()
		for reaction in self.REACTIONS:
			(name, reversibility, notes, equation) = self.REACTIONS[reaction]
			for note in notes: 
				if 'EC: ' in note:
					ec = note.lstrip("EC: ")
					if ec != '.':
						ecs.add(ec)
			rxnInfo = []
			if reaction in self.rxnSeedDB.keys():
				rxnInfo = self.rxnSeedDB[reaction]
			elif reaction in self.rxnPalssonDB.keys():
				rxnInfo = self.rxnPalssonDB[reaction]
			if rxnInfo != []:
				if rxnInfo[2] != ".":
					ecsSeed = rxnInfo[2].split("|")
					for ec in ecsSeed:
						if ec != "":
							ecs.add(ec)
				if rxnInfo[9] != ".":
					ecsPalsson = rxnInfo[9].split("; ")
					for ec in ecsPalsson:
						ec = ec.replace(" ", "")
						ecs.add(ec)
				if rxnInfo[15] != ".":
					ecsPalsson2 = rxnInfo[15].split(";")
					for ec in ecsPalsson2:
						ec = ec.replace(" ", "")
						ecs.add(ec)
				if rxnInfo[20] != ".":
					ecsKegg = rxnInfo[20].split(";")
					for ec in ecsKegg:
						ec = ec.replace(" ", "")
						if ec != "":
							ecs.add(ec)
		for ec in ecs:
			ecfile.write("%s\n" % ec)

	def gpr2(self, filename, readquiet):
		#read gpr.txt file
		if not readquiet:
			print 'gpr from', filename
		file = open(filename)
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if 'rg\t' == line[:3]:
				rg, rxn, gpr = line.split('\t')[0], line.split('\t')[1], line.split('\t')[2]
				#skip 'illegal' reactions
				if 'R_ILL_' == rxn[:6]: continue
				if rxn[:2] != 'R_':
					rxn = 'R_' + rxn
				gurobicb.add_note(self, rxn, 'Gene_association: ' + gpr)
				#skip if there is no gpr...
				if gpr == '.':
					continue
				#if there is a gpr statement, add to REACTS and SIMPLEGPR...
				self.REACTS[rxn] = 1
				self.SIMPLEGPR[rxn] = gpr
				#if there is an 'and' statement in gpr, then this must be a protein complex...
				if 'and' in gpr:
					self.COMPLEXES[rxn] = 1
				#if there is more than one gene in gpr, and only 'or' statements, then this must be an isozyme...
				if len(gpr.split()) > 1 and not 'and' in gpr:
					self.ISOZYMES[rxn] = 1
				for item in gpr.split():
					if item == 'and' or item == 'or':
						continue
					#take out any parentheses and just get list of genes...ASSUMES THAT PARENTHESES ARE NOT IN GENE IDENTIFIER!!!
					item = item.replace('(', '')
					item = item.replace(')', '')
					if item != '.':
						self.GENES[item] = 1
		if not readquiet:
			print

	def writeRuppinLP(self, RXNID, tempHiRxns, tempLoRxns, outfilename, bounds, lowerbounds, upperbounds, mc, notsrc, notesc, epsilon, wildtype, force):
		""" Formerly called writemodifiedLP, written by Seth; this writes the LP file to be read by gurobi for the Ruppin algorithm.
			Arguments:
				- RXNID: 	.	.	.	.	reaction being tested by ruppinFVA, only used if wildtype=False
				- tempHiRxns:	.	.	.	dictionary of reactions called high according to gene expression
				- tempLoRxns:	.	.	.	dictionary of reactions called low according to gene expression
				- outfilename: 	.	.	.	desired lp file name
				- bounds:	.	.	.	.	string printed to lp defining bounds for optimization problem
				- lowerbounds/upperbounds: 	.	dictionary mappings from reactions to their lower/upper bounds
				- mc: 	.	.	.	.	string printed to lp defining mass conservation constraints
				- notsrc:	.	.	.	.	-
				- notesc:	.	.	.	.	-
				- epsilon:	.	.	.	.	Cutoff value (float type) for whether a reaction is called 'active'
				- wildtype: .	.	.	.	Boolean value, normally true, but set to false if using ruppinFVA to test reaction states
				- force: 	.	.	.	.	type of test to apply to test reaction in ruppinFVA; can be either 'Off', 'Forward', or 'Reverse'
		"""
		#this is top of .lp file
		head = """\\* Problem: ruppin *\\ \n\nMaximize\n Agreement:"""

		#make objective section of .lp; make 'Generals' section of .lp file (this specifies list of binary variables)
		#also continue to add to 'Bounds' section
		objective = ''
		generals = '\nGenerals\n'

		#go thru reactions expected to have HI expression	
		for i, rxn in enumerate(tempHiRxns.keys()):	
	#		if not wildtype and rxn == RXNID: continue
			#add a carriage return to objective section on every 3rd rxn...
			if i%3 == 0 and i != 0:
				objective = objective + '\n'
			#HI reactions have both a yplus and yminus variable...
			objective = objective + ' + yplus(' + rxn + ')'
			objective = objective + ' + yminus(' + rxn + ')'
			bounds = bounds + ' 0 <= yplus(' + rxn + ') <= 1\n'
			bounds = bounds + ' 0 <= yminus(' + rxn + ') <= 1\n'
			generals = generals + ' yplus(' + rxn + ')\n'
			generals = generals + ' yminus(' + rxn + ')\n'

		#go thru reactions expected to have LO expression	
		for i, rxn in enumerate(tempLoRxns.keys()):
	#		if not wildtype and rxn == RXNID: continue		
			#add a carriage return to objective section on every 3rd rxn...
			if i%3 == 0 and i != 0:
				objective = objective + '\n'
			#LO reactions have only a yplus...
			objective = objective + ' + yplus(' + rxn + ')'
			bounds = bounds + ' 0 <= yplus(' + rxn + ') <= 1\n'
			generals = generals + ' yplus(' + rxn + ')\n'
		
		#start 'Subject to' section of file; this section contains mass conserv, and constraints that all src / esc rxns other
		#than those specified are = 0
		#this would probably be where to put constraint for certain reactions to be 'active' !!!	
		st = '\n\nSubject to\n'
	
		if not wildtype:
			# change from Seth's version: new argument forceActive boolean
			## add reaction-specific contraint ##
			if force == 'Forward':								
				#st = st + ' ForceActive(' + RXNID + '): yplus(' + RXNID + ') + yminus(' + RXNID + ') = 1\n'
				bounds = bounds + ' v(' + RXNID + ') >= ' + str(epsilon) + '\n'
			elif force == 'Reverse':
				bounds = bounds + ' v(' + RXNID + ') <= ' + str(epsilon) + '\n'
			elif force == 'Off':
				#st = st + ' ForceInactive(' + RXNID + '): yplus(' + RXNID + ') = 1\n'
				bounds = bounds + ' -' + str(epsilon) + ' <= v(' + RXNID + ') <= ' + str(epsilon) + '\n'
						
		#the following two sections corresponds to lines 3, 4, 5 on p. 1009 of Ruppin article, the 'business end' of the algorithm
		hirxnstr = ''
		#this is the part for reactions that are supposed to be active, based on gene expression
		for rxn in tempHiRxns.keys():
	#		if not wildtype and rxn == RXNID: continue	
			#get rxn upper and lower bounds
			lb, ub = lowerbounds[rxn], upperbounds[rxn]
			#this is quantity in parenthesis from line 3, p. 1009 of Ruppin article
			quant1 = str(lb - epsilon)
			#eliminate any trailing '.0' from numbers...unnecessary
			if len(quant1) > 2:
				if quant1[-2:] == '.0': quant1 = quant1[:-2]
			#if the quantity = -1 or = 1, replace this with just a simple '-' or '+'	
			if quant1 == '-1': quant1 = '-'
			elif quant1 == '1': quant1 = '+'
			elif quant1[0] == '-': quant1 = '- ' + quant1[1:]
			else: quant1 = '+ ' + quant1
			#this is quantity in parenthesis from line 4, p. 1009 of Ruppin article
			quant2 = str(ub + epsilon)
			#eliminate any trailing '.0' from numbers...unnecessary
			if len(quant2) > 2:
				if quant2[-2:] == '.0': quant2 = quant2[:-2]
			#if the quantity = -1 or = 1, replace this with just a simple '-' or '+'	
			if quant2 == '-1': quant2 = '-'
			elif quant2 == '1': quant2 = '+'
			elif quant2[0] == '-': quant2 = '- ' + quant2[1:]
			else: quant2 = '+ ' + quant2
			#this is the RHS of the HighForward equation
			rhlb = str(lb)
			#eliminate any trailing '.0' from numbers...unnecessary
			if len(rhlb) > 2:
				if rhlb[-2:] == '.0': rhlb = rhlb[:-2]
			#this is the RHS of the HighBackward equation
			rhub = str(ub)
			#eliminate any trailing '.0' from numbers...unnecessary
			if len(rhub) > 2:
				if rhub[-2:] == '.0': rhub = rhub[:-2]
			#add HighForward and HighBackward lines to this section
			hirxnstr = hirxnstr + ' HighForward(' + rxn + '): + v(' + rxn + ') ' + quant1 + ' yplus(' + rxn + ') >= ' + rhlb + '\n'
			hirxnstr = hirxnstr + ' HighBackward(' + rxn + '): + v(' + rxn + ') ' + quant2 + ' yminus(' + rxn + ') <= ' + rhub + '\n'	
		lorxnstr = ''
		#this is the part for reactions that are supposed to be inactive, based on gene expression
		for rxn in tempLoRxns.keys():
	#		if not wildtype and rxn == RXNID: continue	
			lb, ub = str(lowerbounds[rxn]), str(upperbounds[rxn])
			#eliminate any trailing '.0' from numbers...unnecessary
			if len(lb) > 2:
				if lb[-2:] == '.0': lb = lb[:-2]
			#if lowerbound < 0 (e.g., lb = -1000), rewrite lowerbound as '-1000' for the RHS of the LowMin reaction, and as '- 1000' for the LHS of the LowMin reaction
			if lb[0] == '-':
				rightlb = '-' + lb[1:]
				lb = '- ' + lb[1:]
			#if lowerbound >= 0 (e.g., lb = 0), rewrite lowerbound as '0' for the RHS of the LowMin reaction, 
			#and as '+ 0' for the LHS of the LowMin reaction (although if = 0, it will change again below)
			else:
				rightlb = lb
				lb = '+ ' + lb
			#eliminate any trailing '.0' from numbers...unnecessary
			if len(ub) > 2:
				if ub[-2:] == '.0': ub = ub[:-2]
			#if upperbound < 0 (e.g., lb = -1000), rewrite upperbound as '-1000' for the RHS of the LowMax reaction, and as '- 1000' for the LHS of the LowMax reaction
			if ub[0] == '-':
				rightub = '-' + ub[1:]

				ub = '- ' + ub[1:]
			#if upperbound >= 0 (e.g., ub = 1000), rewrite lowerbound as '1000' for the RHS of the LowMax reaction, 
			#and as '+ 1000' for the LHS of the LowMax reaction
			else:
				rightub = ub
				ub = '+ ' + ub
			#if lowerbound = 0, then LowMin equation takes very simple form...
			if lb == '+ 0':
				lomin = ' LowMin(' + rxn + '): + v(' + rxn + ') >= -0\n'
			#otherwise, LowMin form is as below...
			else:
				lomin = ' LowMin(' + rxn + '): + v(' + rxn + ') ' + lb + ' yplus(' + rxn + ') >= ' + rightlb + '\n'
			lomax = ' LowMax(' + rxn + '): + v(' + rxn + ') ' + ub + ' yplus(' + rxn + ') <= ' + rightub + '\n'
			#add LowMin, LowMax equations to this section
			lorxnstr = lorxnstr + lomin + lomax
		
		#prints the lp file
		print >>open(outfilename, 'w'), head + objective + st + mc + notsrc + notesc + hirxnstr + lorxnstr + bounds + generals + '\nEnd'
		
	def ruppin( self, geneexprfile, gammas=(0, 0.1), epsilon=0.1, FVA=False, forceBiomass=True ):

		#calculate hi and lo reactions, based on gprs and gene expression data
#		hirxnset, lowrxnset = mapGPR_current.getRxnExprDict(geneexprfile, 'cthmodel.gpr.robusto.txt' , gamma)
		hirxnset, lowrxnset = mapGPR_Chris.getRxnExprDict(geneexprfile, self.SIMPLEGPR , gammas)
		#Add biomass constraint if forced:
		if forceBiomass:
			self.set_constraint('R_biomass_target', epsilon, 1000)
		#make sets and parameters....
		mets = {}				## used to make mass conservation constraints (basically, like S matrix)
		lowerbounds = {}		## mapping from rxn to its lowerbound
		upperbounds = {}		## mapping from rxn to its upperbound
		knownsourceset, knownescapeset = {}, {}		## specified sources and escapes
		bounds = '\nBounds\n'						## this is string for section of the .lp file containing bounds...construct this 'on the fly'
		
		for ID in self.REACTIONS:
			#exclude any reference to biomass equation
			if (ID == 'R_BIOMASS') or (ID == 'R_biomass_target'):
				continue
			#get info on this reaction
			name, reversible, notes, equation = self.REACTIONS[ID]
			
			#add sources and escapes to their respective sets
			if 'R_ESC_' in ID:
				knownescapeset['M_' + ID[6:]] = 1
			if 'R_SRC_' in ID:
				knownsourceset['M_' + ID[6:]] = 1
						
			#if there have been specific constraints already set, use them...
			if ID in self.CONSTRAINTS:
				lbound, ubound = self.CONSTRAINTS[ID]
			#otherwise create constraints on the fly, using reaction reversibility and m.VMAX...
			else:
				ubound = self.VMAX
				if bool(reversible):
					lbound = '-' + self.VMAX
				else:
					lbound = '0'
			if not 'R_ESC_' in ID and not 'R_SRC_' in ID:
				#add lower and upper bounds to dictionaries
				lowerbounds[ID] = float(lbound)
				upperbounds[ID] = float(ubound)
				#append this reaction's info to 'Bounds' section of .lp file
				bounds = bounds + ' ' + lbound + ' <= v(' + ID + ') <= ' + ubound + '\n'
					
			#create a data structure called 'mets': keys are metabolites, values are (reactionID, coef); this is essentially "S * v"
			#for reactant and product side of equation, skip any boundary metabolites (if metabolite ends in '_b')
			for reactant in equation[0]:
				species, coef = reactant[0], '-' + str(reactant[1])
				if '_b' == species[-2:]:
					continue
				if not species in mets:
					mets[species] = []
				if not 'R_SRC_' in ID and not 'R_ESC_' in ID:		
					mets[species].append((ID, coef))
				
			for product in equation[1]:
				species, coef = product[0], product[1]
				if '_b' == species[-2:]:
					continue
				if not species in mets:
					mets[species] = []
				if not 'R_SRC_' in ID and not 'R_ESC_' in ID:		
					mets[species].append((ID, coef))

		#::::::::::::::::::::::::::::::::::::::data structures made............
		#::::::::::::::::::::::::::::::::::::::start making strings that will compose the LP file...............

		#::::::::::::::::::::::::::::::::::::::make 'reusable' parts of LP (mc, notsrc, notesc)...............
		#first part is the mass conservation section
		mc = ''
		for spec in mets:
			mc = mc + ' MassConserv(' + spec + '): '
			for rxn, coef in mets[spec]:
			#eliminate any trailing '.0' from numbers...unnecessary
				if len(coef) > 2:
					if coef[-2:] == '.0': coef = coef[:-2]
				if coef == '-1': coef = '-'
				elif coef == '1': coef = '+'
				elif coef[0] == '-': coef = '- ' + coef[1:]
				else: coef = '+ ' + coef
				mc = mc + coef + ' v(' + rxn + ') '
			mc = mc + ' + src(' + spec + ') - esc(' + spec + ') = -0\n'
		#next part is the notsources / notescapes section
		notsrc, notesc = '', ''
		for spec in mets:
			if not spec in knownsourceset:
				notsrc = notsrc + ' NotSources(' + spec + '): + src(' + spec + ') = -0\n'
			else:
				bounds = bounds + ' 0 <= src(' + spec + ') <= 1000\n'
			if not spec in knownescapeset:
				notesc = notesc + ' NotEscapes(' + spec + '): + esc(' + spec + ') = -0\n'
			else:
				bounds = bounds + ' 0 <= esc(' + spec + ') <= 1000\n'
		
		# Solve for fluxes for wildtype case:
		#print hirxnset
		#print lowrxnset
		self.hirxnset = hirxnset
		self.lowrxnset = lowrxnset
		
		wildtype=True
		force='Off'	
		self.writeRuppinLP('', hirxnset, lowrxnset, 'wt.lp', bounds, lowerbounds, upperbounds, mc, notsrc, notesc, epsilon, wildtype, force)
		wtmodel = read('wt.lp')
		wtmodel.optimize()
		self.STATUS = wtmodel.getAttr('Status')
		self.OBJECTIVE_VALUE =  wtmodel.getAttr('ObjVal') 
		for var in wtmodel.getVars():
				if 'v(R' in var.getAttr('VarName'):
					rxn = var.getAttr('VarName').replace('v(','').replace(')','')
					self.REACTION2FLUXVALUE[rxn] = str(var.getAttr('X'))
		os.system('rm wt.lp')

def flipmembership (rxnid, hiorig, loorig):
	"""function to flip reaction membership in hi and lo sets"""
	HI, lo, hi, LO = {}, {}, {}, {}
	if rxnid in hiorig:
		HI = hiorig.copy()
		lo = loorig.copy()
		for r in hiorig:
			if r != rxnid:
				hi[r] = 1
			else:
				LO[r] = 1
		for r in loorig:
			LO[r] = 1
		return HI, lo, hi, LO
	elif rxnid in loorig:
		hi = hiorig.copy()
		LO = loorig.copy()
		for r in hiorig:
			HI[r] = 1
		for r in loorig:
			if r != rxnid:
				lo[r] = 1
			else:
				HI[r] = 1
		return HI, lo, hi, LO

def readExprFile ( geneexprfile, gamma ):
	""" Read gene expression file and create boolean expression file that is read by gurobicb.ruppin() """
	expr = open(geneexprfile)
	boolFileName = '.'.join([geneexprfile, str(gamma), 'txt'])
	exprBool = open(boolFileName, 'w')
	while True:
		line = expr.readline()
		if line == '': break
		line = line.rstrip()
		if line == '': continue
		if line[0] == '#': continue
		line = line.split('\t')
		if float(line[1]) == 0:
			newLine = '\t'.join([line[0], '-1\n'])
			exprBool.write(newLine)
		elif float(line[1]) > gamma:
			newLine = '\t'.join([line[0], '1\n'])
			exprBool.write(newLine)
		else:	
			newLine = '\t'.join([line[0], '0\n'])
			exprBool.write(newLine)
	exprBool.close()
	expr.close()
	
