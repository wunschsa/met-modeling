#script purpose: make and analyze metabolic models in Python
#cb is class for constraint-based models, allows reading/writing of *.sbml files; 
	#uses Python 2.4.2 with standard libraries
	#other dependencies: glpsol (from glpk), libSBML from http://sbml.org/software/libsbml/
	#also uses eq.py module, written to deal with parsing reaction equations, metabolites, compartments, etc.

"""
data structures for a constraint-based model:

modelid = modelid (string)

modelname = modelname (string)

compartments -> { compartmentname : {id:compartmentname, outside:outsidecompartment(None)}, ... }

species -> { speciesid : {id:speciesid, name:speciesname, charge:speciescharge, compartment:speciescompartment, boundarycondition:speciesBC}, ... }

reactions -> { reactionid: ( name, rev, {<notes>}, [[(r1, coef1), (r2, coef2), ... ], [(p1, coef1), (p2, coef2)]] ), ... }

NOTES:
1. currently, reversibility is determined by parsing rxnequation when reading tab-delimited input files,
	i.e., the column 'REVERSIBILITY' is ignored. Might eventually change this, perhaps eliminate column from input, or use as a check.
"""

import os, re, time, pickle		#standard Python 2.4.2 modules
import eq						#custom Python modules
from libsbml import *			#libSBML


SPECIES_DB = pickle.load(open('/Users/seth/Desktop/research/databases/palsson.models/speciesDB', 'rb'))

#regular expression to capture ec numbers
ecnum_re = re.compile(r"""\d+\.(\d|-)+\.(\d|-)+\.(\d|-)+""")

#these are reactions where the equation is not quite the same across the palsson models for all organisms'
DISCREPANCIES = {'R_DHFS':1, 'R_DHPS2':1, 'R_MTHFR2':1, 'R_MTHFR3':1, 'R_METS':1, 
				'R_MTHFCm':1, 'R_GTPCI':1, 'R_MTHFD':1, 'R_MTHFC':1, 'R_MTHFD2':1, 
				'R_MTHFDm':1, 'R_QULNS':1}

#dictionary mapping one letter abbreviation used as suffix on species ID to corresponding compartment				
#note: this suffix to compartment mapping will OVERRIDE the compartment from SPECIES_DB 
#(e.g., if suffix 'x' means 'Peroxisome' in DB, but defined below as 'Glycosome', compartment in model will be 'Glycosome')
abbrev2compartment = {
						'c':('Cytosol', 'Extraorganism'),
						'r':('EndoplasmicReticulum', 'Cytosol'),
						'e':('Extraorganism', False),
						'g':('GolgiApparatus', 'Cytosol'),
						#'l':('Lysosome', 'Cytosol'),
						'l':('Reservosome', 'Cytosol'),
						'm':('Mitochondria', 'Cytosol'),
						'n':('Nucleus', 'Cytosol'),
						#'x':('Peroxisome', 'Cytosol'),
						#'y':('Glycosome', 'Cytosol')
						'x':('Glycosome', 'Cytosol'),
						'v':('Vacuole', 'Cytosol'),
						'b':('Extraorganism', False),
						'p':('BtwnMitoInnerOuter', 'Cytosol')
				
											}
											
def derive_coef (original_raw):
	#Given coeficient from eq data structure, derive the coeficient to be used in the *.lp file
	coef = ' '
	raw = str(original_raw)
	if raw[0] == '-':
		integ = raw[1:]
		if integ == '1':
			coef = coef + '-'
		else:
			coef = coef + '-' + integ
	else:
		integ = raw
		if integ == '1':
			coef = coef + '+'
		else:
			coef = coef + '+' + integ
	return coef
											
def ensure_boolean (id, val):
	#ensure that boundaryCondition is a boolean value
	if type(val) == type(True):
		return val
	else:
		assert (('rue' in val) or ('alse' in val)), 'Something wrong with boolean value: %s %s' % (id, val)
		if 'rue' in val:
			boolvar = True
		elif 'alse' in val:
			boolvar = False
		return boolvar
		

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

class cb:
	"""
	Class for creation and manipulation of constraint-based metabolic models.
		
	"""
	
	def __init__ (self):
	
		#make a timestamp and use it as default 'model ID'...
		timestamp = time.strftime("%Y_%m_%d_%H_%M_%S")
		self.MODEL_ID = 'Model' + timestamp

		self.MODEL_NAME = ''
		self.COMPARTMENTS = {}
		self.SPECIES = {}
		self.REACTIONS = {}
		self.SOURCES = []
		self.ESCAPES = []
		self.NOTSOURCES = []
		self.NOTESCAPES = []
		self.OBJECTIVE_EQUATION = ''
		self.GENES, self.TRANSCR, self.PROTS, self.REACTS =	{}, {}, {}, {}

				
		#default max/min value for fluxes
		self.VMAX = '1000'
		
		#holds user-specified reaction flux constraints
		self.CONSTRAINTS = {}
		
		self.OBJECTIVE = ('Maximize', 'R_biomass')
		self.STATUS = ''
		self.OBJECTIVE_VALUE = ''
		self.REACTION2FLUXVALUE = {}
		self.MINBIOMASS = '0.001'			
				
								
	def set_id (self, ID):
		"Sets the name of the model. For now, model ID (as opposed to model name) will be a timestamp."
		self.MODEL_ID = ID


	def set_name (self, ID):
		"Sets the name of the model. For now, model ID (as opposed to model name) will be a timestamp."
		self.MODEL_NAME = ID
		

	def set_objective (self, goal, ID):
		"Set whether to maximize/minimize and which reaction. Example: m.set_objective('Maximize', 'R_biomass')."
		self.OBJECTIVE = (goal, ID)
	
	
	def delete_reaction (self, id):
		"Given a reactionID, delete this key, value pair from REACTIONS. Does not delete reaction species from SPECIES."
		if id in self.REACTIONS:
			del self.REACTIONS[id]
		else:
			print 'WARNING--cannot delete %s: not in REACTIONS' % (id)
			
	
	def get_equation (self, id):
		"Given a reactionID, prettyprint the reaction equation."
		name, reversible, notes, equation = self.REACTIONS[id]
		reactionequation = eq.makestring(equation, reversible)
		return reactionequation
		
		
	def add_species (self, id, name, compartment, charge, boundaryCondition):
		"Write a new species into the species list for the model. Example: m.add_species('M_h2o_c', 'water', 'cytosol', '0', 'False'). Params are ID, name, compartment, charge, boundaryCondition."
		self.SPECIES[id] = {'id':id, 'name':name, 'compartment':compartment, 'charge':charge, 'boundaryCondition':boundaryCondition}


	def add_compartment (self, id, outside=None):
		"Add a new compartment to the model. Example: m.add_compartment('Cytosol', outside='Extraorganism')"
		self.COMPARTMENTS[id] = {'id':id}
		if outside:
			self.COMPARTMENTS[id]['outside'] = outside
		
		
	def set_constraint (self, id, lbound, ubound):
		"Given a reaction ID, set lbound and ubound. Example: m.set_bounds('R_UNK2', 0, 1000)."
		if id in self.REACTIONS:
			self.CONSTRAINTS[id] = (str(lbound), str(ubound))
		else:
			print 'WARNING--cannot set constraint for %s: not in REACTIONS' % (id)
	
	
	def reset_vmax (self, newvalue):
		"Resets the default flux limits to the provided value."
		newvalue_str = str(newvalue)
		for constraint in self.CONSTRAINTS:
			lbound, ubound = self.CONSTRAINTS[constraint]
			if lbound == '-' + self.VMAX:
				lbound = '-' + newvalue_str
			if ubound == self.VMAX:
				ubound = newvalue_str
			self.CONSTRAINTS[constraint] = (lbound, ubound)
		self.VMAX = newvalue_str
				
				
	def	add_note (self, ID, notetext):
		"Add a note to the corresponding reaction. Example: m.add_note('R_PGM', 'SUBSYSTEM: ss glycolysis')."
		if not ID in self.REACTIONS:
			print 'WARNING--cannot add "%s" to notes for %s: %s not in REACTIONS' % (notetext, ID, ID)
		else:	
			name, rev, notes, eq = self.REACTIONS[ID]
			notes[notetext] = 1
			self.REACTIONS[ID] = (name, rev, notes, eq)


	def	delete_note (self, ID, notetext):
		"Delete a note from the corresponding reaction. Example: m.delete_note('R_PGM', 'SUBSYSTEM: ss glycolysis')."
		if not ID in self.REACTIONS:
			print 'WARNING--cannot delete "%s" from notes of %s: %s not in REACTIONS' % (notetext, ID, ID)
		else:	
			name, rev, notes, eq = self.REACTIONS[ID]
			if notetext in notes:
				del notes[notetext]
				self.REACTIONS[ID] = (name, rev, notes, eq)
			else:
				print 'WARNING--cannot delete "%s" from notes of %s: %s not in notes' % (notetext, ID, notetext)


	def add_reaction (self, ID, name, rev, notes, equation):
		"Add a new reaction into the model. Example: m.make_reaction('R_ss_biomass', 'ssa biomass', 'false', {'CONFIDENCE: 1':1, 'SUBSYSTEM: biomass':1, 'GPR: ':1, 'EC Number: ':1}, [[('M_atp_c', '1')],[('M_adp_c', '1'), ('M_pi_c', '1')]])"
		if ID in self.REACTIONS:
			print ID, 'already in REACTIONS'
		else:
			self.REACTIONS[ID] = (name, rev, notes, equation)
			if ID in DISCREPANCIES:
				warning_equation = eq.makestring(equation, rev)
				print ID, 'discrepant across models. Using:', warning_equation
			for species, coef in (equation[0] + equation[1]):
				#add compartment if necessary
				compartment, outside = abbrev2compartment[species[-1:]]
				if not compartment in self.COMPARTMENTS:
					cb.add_compartment(self, compartment, outside)
				#add species if necessary
				if not species in self.SPECIES:
					name, db_compartment, charge, boundaryCondition = SPECIES_DB[species]
					cb.add_species(self, species, name, compartment, charge, boundaryCondition)
				

	def write_lp (self, lpfilename):
		"Write current model in *.lp file format. Provide a name for the file. Automatically called by 'solve' method."
		outfile = open(lpfilename, 'w')
		
		mets = {}
		constraints = {}

		for ID in self.REACTIONS:
			
			name, reversible, notes, equation = self.REACTIONS[ID]
						
			#if there have been specific constraints already set, use them...
			if ID in self.CONSTRAINTS:
				lbound, ubound = self.CONSTRAINTS[ID]
			#otherwise create constraints on the fly, using reaction reversibility and self.VMAX...
			else:
				ubound = self.VMAX
				if bool(reversible):
					lbound = '-' + self.VMAX
				else:
					lbound = '0'
			constraints[lbound + ' <= ' + ID + ' <= ' + ubound] = 1
				
			#create a data structure called 'mets': keys are metabolites, values are (reactionID, coef); this is essentially "S * v"
			for reactant in equation[0]:
				species, coef = reactant[0], '-' + str(reactant[1])
				if '_b' == species[-2:]:
					continue
				if not species in mets:
					mets[species] = []
				mets[species].append((ID, coef))
				
			for product in equation[1]:
				species, coef = product[0], product[1]
				if '_b' == species[-2:]:
					continue
				if not species in mets:
					mets[species] = []
				mets[species].append((ID, coef))

		#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		#WRITE *.LP FILE....

		assert self.OBJECTIVE[1], 'No objective has been defined.'
		assert self.OBJECTIVE[1] in self.REACTIONS, 'Objective is not a reaction in the model.'

		#print .lp file header
		print >>outfile, '\\\ '
		print >>outfile, '\n'
		print >>outfile, '\\\ Objective function'
		print >>outfile, self.OBJECTIVE[0]
		print >>outfile, '  Z : ' + self.OBJECTIVE[1]
		print >>outfile, '\n'
				
		#print out 'Subject To' part of .lp file
		print >>outfile, '\\\ Mass balance equations'
		print >>outfile, 'Subject To'		

		for m in mets:
			fcs = mets[m]
			line = '  ' + m + ' :'
			
			for fc in fcs:
				flux = fc[0]
				coef = derive_coef(fc[1])
				line = line + coef + ' ' + flux
			line = line + ' = 0'
			print >>outfile, line

		#print constraints
		print >>outfile, '\n'
		print >>outfile, '\\\ Flux constraints'
		print >>outfile, 'Bounds'
		print >>outfile, '\n'

		for c in constraints:
			print >>outfile, '  ' + c

		#print *.lp file suffix...
		print >>outfile, '\n'
		print >>outfile, 'End'
		
		
	def solve (self, out=False, verbose=True):
		"Run glpsol to see if solution exists. Argument is out=<fn> (if no filename given, just solves without writing output to a file, for checking purposes)."
		
		#if no escapes have been specified, make escapes on all metabolites in the model
		if self.ESCAPES == []:
			print '# No escapes currently specified. Adding escape fluxes to all metabolites in model.'
			cb.set_escapes(self, self.SPECIES.keys())

		#make timestamp...
		timestamp = time.strftime("%Y_%m_%d_%H_%M_%S")
			
		if out:
			#set names of outputfiles
			lpfilename = out + '.' + timestamp + '.lp'
			rawoutfilename = out + '.' + timestamp + '.out'
			xlsfilename = out + '.' + timestamp + '.xls'
			
		else:
			#if out not specified, make tmp filenames (these files deleted below in this case)
			lpfilename = 'tmp.' + timestamp + '.lp'
			rawoutfilename = 'tmp.' + timestamp + '.out'
			xlsfilename = 'tmp.' + timestamp + '.xls'
			
		#write the *.lp file
		cb.write_lp(self, lpfilename)

		#construct glpsol command and execute, following calls glpsol from .lib; original command commented out below
		command = '/Users/seth/.lib/python/glpsol --cpxlp ' + lpfilename + ' -o ' + rawoutfilename + ' > glpsol.log'
		os.system(command)
		
		self.REACTION2FLUXVALUE = {}
		
		#read rawoutput file, parse results
		file = open(rawoutfilename)
		lines = file.readlines()
		for i, line in enumerate(lines):
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			col = line.split()
			
			#collects info on whether optimization was OK, and if so, what was the value of the Objective fnc
			if 'Status:' == line[0:7]:
				tmp = line.split()
				self.STATUS = tmp[1]
			if 'Objective:' == line[0:10]:
				tmp = line.split()
				self.OBJECTIVE_VALUE = float(tmp[3])
				
			#skipping irrelevant lines	
			if len(col) > 1:
				#find lines that have the name of a flux as col[1]
				if col[1] in self.REACTIONS:
					if len(col) < 4:
						nextline = lines[i+1]
						nextcol = nextline.split()
						self.REACTION2FLUXVALUE[col[1]] = nextcol[1]
					else:
						self.REACTION2FLUXVALUE[col[1]] = col[3]
							
		
		#send results to *.xls file
		if out:
			cb.list_reactions(self, out=xlsfilename, showfluxvalues=True)

		#if you didn't ask to save the output, delete the tmp output files
		if not out:
		
			if verbose:
				cb.list_reactions(self, showfluxvalues=True)
			
			command1 = 'rm ' + lpfilename
			command2 = 'rm ' + rawoutfilename

			os.system(command1)
			os.system(command2)
				
		
	def list_reactions (self, out=False, showfluxvalues=True):
		"Prints a list of reactions from current model, organized by path, then ecnumber. Arguments are out=<fn>, showfluxvalues=<True/False>. Defaults are False, True."
		cache = {}
		for reaction in self.REACTIONS:
			name, reversible, notes, equation = self.REACTIONS[reaction]
			reactionequation = eq.makestring(equation, reversible)
			#print reaction + '\t' + name + '\t' + str(reversible) + '\t.\t.\t' + reactionequation
			#search for any ec numbers and pathways in reaction notes; it IS possible for there to be > 1 ec or pathway for a given reaction
			confidence, gpr = '?', '?'
			holder = {'pathways':{}, 'ecs':{}}
			for note in notes:
				if 'SUBSYSTEM: ' in note:
					holder['pathways'][note[11:]] = 1
				if 'EC: ' in note:
					holder['ecs'][note[4:]] = 1
				if 'CONFIDENCE: ' in note:
					confidence = note[12:]
				if 'GPR: ' in note:
					gpr = note[5:]
										
			
			#add to cache for printing...																		
			for pathwayname in holder['pathways']:
				for ec in holder['ecs']:
					if not pathwayname in cache:
						cache[pathwayname] = {}
					if not ec in cache[pathwayname]:
						cache[pathwayname][ec] = {}
						
					#if this is printing the results of 'solve', then get flux activities...
					#reactionID	name	rev	pathway	ec	equation	confidence	gpr
					if showfluxvalues and self.REACTION2FLUXVALUE.get(reaction, '.') != '0':
						cache[pathwayname][ec][ ('\t').join((reaction, reaction[2:], name, str(reversible), pathwayname, ec, self.REACTION2FLUXVALUE.get(reaction, '.'), reactionequation, gpr)) ] = 1
					if not showfluxvalues:
						cache[pathwayname][ec][ ('\t').join((reaction, reaction[2:], name, str(reversible), pathwayname, ec, reactionequation, gpr)) ] = 1
		
		paths = cache.keys()
		paths.sort()		
		
		if out:
			outfi = open(out, 'w')
				
			for path in paths:
				ecs = cache[path].keys()
				ecs.sort()
				for ec in ecs:
					for r in cache[path][ec]:
						print >>outfi, r
				#print >>outfi, '\n'
				
		else:
			for path in paths:
				ecs = cache[path].keys()
				ecs.sort()
				for ec in ecs:
					for r in cache[path][ec]:
						print r
				#print '\n'
				
		
	def write_constraints (self, outfilename):
		"Write a pickled object containing current model reaction constraints. Specify the filename."
		pickle.dump(self.CONSTRAINTS, open(outfilename, 'wb'), -1)
		
		
	def load_constraints (self, infilename):
		"Load model constraints from a pickled object. Specify the filename. For a given reaction, overwrites any existing constraints if there is a constraint in the pickled object."
		constraints_holder = pickle.load(open(infilename, 'rb'))
		for constraint in constraints_holder:
			(lbound, ubound) = constraints_holder[constraint]
			self.CONSTRAINTS[constraint] = (lbound, ubound)
			
										
	def set_sources (self, sourcelist):
		"Add source fluxes for all sources."
		
		assert len(sourcelist) > 0, 'Must specify 1 or more sources'
		self.SOURCES = sourcelist
		
		for species in sourcelist:
			rev = False
			notes = {'SUBSYSTEM: SourceFlux':1, 'EC: .':1}
			boundaryflux_ID = 'R_SRC_' + species[2:]
			boundaryspecies_ID = species[:-1] + 'b'
			eq = [[(boundaryspecies_ID, '1')], [(species, '1')]]
			
			#can get species info from species already in model, or from SPECIES_DB
			#specdict = self.SPECIES[species]
			#name, compartment, charge, boundaryCondition = specdict['name'], specdict['compartment'], specdict['charge'], specdict['boundaryCondition']
			name, compartment, charge, boundaryCondition = SPECIES_DB[species]
			
			SPECIES_DB[boundaryspecies_ID] = (name, compartment, charge, 'true')
			cb.add_reaction(self, boundaryflux_ID, name + ' source flux', rev, notes, eq)
			#if species[-1] == 'e':
			#	cb.set_constraint(self, boundaryflux_ID, '0', str(1000.0 * float(self.VMAX)) )

	def set_escapes (self, escapelist):
		"Add escape fluxes for all escapes (if escapes=[], add escapes for all species in model)."
		
		self.ESCAPES = escapelist
		
		for species in escapelist:
			#do not add escapes for boundary metabolites (avoid infinite regression of escapes)
			if not species[-1] == 'b':
				rev = False
				notes = {'SUBSYSTEM: EscapeFlux':1, 'EC: .':1}
				boundaryflux_ID = 'R_ESC_' + species[2:]
				boundaryspecies_ID = species[:-1] + 'b'
				eq = [[(species, '1')], [(boundaryspecies_ID, '1')]]
				specdict = self.SPECIES[species]
				name, compartment, charge, boundaryCondition = specdict['name'], specdict['compartment'], specdict['charge'], specdict['boundaryCondition']
				SPECIES_DB[boundaryspecies_ID] = (name, compartment, charge, 'true')
				cb.add_reaction(self, boundaryflux_ID, name + ' escape flux', rev, notes, eq)
				#if species[-1] == 'e':
				#	cb.set_constraint(self, boundaryflux_ID, '0', str(1000.0 * float(self.VMAX)) )
	
				
	def build(self, model_file):
		#read and build initial model (just the reactions specified)
		print 'model from', model_file
		file = open(model_file)
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if line[0] == '#': continue
			if line[:2] == 'R_':
				col = line.split('\t')
				
				[id, name, rev, pathwaysstr, ecsstr, stringequation] = col[0:6]
				
				reversibility, equation = eq.parse(stringequation)
				
				notes, pathways, ecs = {}, pathwaysstr.split('; '), ecsstr.split('; ')
				#if len(pathways) > 1: print id, "associated with > 1 pathways; splitting list on '; '"
				for pathway in pathways:
					notes['SUBSYSTEM: ' + pathway] = 1
				#if len(ecs) > 1: print id, "associated with > 1 ec numbers; splitting list on '; '"
				for ec in ecs:
					notes['EC: ' + ec] = 1
				
				cb.add_reaction(self, id, name, reversibility, notes, equation)
			#insert new code here to handle gpr, notes, refs, etc...
		print


	def biomass(self, biomass_file):
		#read and define biomass equation...
		print 'biomass from', biomass_file
		biomass_equation = [[], []]
		file = open(biomass_file)
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if line[0] == '#': continue
			col = line.split('\t')
			[rawmet, coef, side] = col[0:3]
			
			#convert metabolites from forms like 'leu-L[c]' to 'M_leu_DASH_L_c'...
			met = eq.convert_metabolite_ext2int(rawmet)
			
			if 'reactant' in side:
				biomass_equation[0].append((met, coef))
				self.NOTSOURCES.append(met)
			elif 'product' in side:
				biomass_equation[1].append((met, coef))
				self.NOTSOURCES.append(met)
			else:
				print 'Warning: biomass component skipped because cannot be idenified as reactant or product-->', line
		#add biomass equation to model, and set this as the objective...
		cb.add_reaction(self, 'R_biomass_target', 'biomass rxn', False, {}, biomass_equation)
		cb.set_objective(self, 'Maximize', 'R_biomass_target')
		cb.set_constraint(self, 'R_biomass_target', '0.0', str(float(self.VMAX)) )
		print


	def sources(self, sources_file):
		#read and define source metabolites.	
		print 'sources from', sources_file
		sources = {}
		file = open(sources_file)
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if line[0] == '#': continue
			col = line.split('\t')
			rawmet = col[0]
			print ' ', rawmet

			#convert metabolites from forms like 'leu-L[c]' to 'M_leu_DASH_L_c'...
			met = eq.convert_metabolite_ext2int(rawmet)

			sources[met] = 1													
		sourcelist = sources.keys()
		cb.set_sources(self, sourcelist)
		print


	def escapes(self, escapes_file):
		#read and define escape metabolites.
		print 'escapes from', escapes_file	
		escapes = {}
		file = open(escapes_file)
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if line[0] == '#': continue
			col = line.split('\t')
			rawmet = col[0]
			print ' ', rawmet

			#convert metabolites from forms like 'leu-L[c]' to 'M_leu_DASH_L_c'...
			met = eq.convert_metabolite_ext2int(rawmet)

			escapes[met] = 1													
		escapelist = escapes.keys()
		cb.set_escapes(self, escapelist)
		print


	def constraints(self, constraints_file):
		#read and define user-specified reaction constraints
		print 'constraints from', constraints_file
		file = open(constraints_file)
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if line[0] == '#': continue
			col = line.split('\t')
			rxn, lbound, ubound = col[0], col[1], col[2]
			print ' ', lbound, '<->', ubound, '\t', rxn
			cb.set_constraint(self, rxn, lbound, ubound)
		print


	def notes(self, notes_file):
		#read and define user-specified reaction constraints
		print 'notes from', notes_file
		file = open(notes_file)
		pmidsearch = ''
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if line[0] == '#': continue
			col = line.split('\t')
			rxn, note = col[0], col[1]
			if 'PMID: ' == note[:6]:
				pmid = note.split()[1][:-1]
				pmidsearch = pmidsearch + pmid + ' '
			cb.add_note(self, rxn, note)
		#if not pmidsearch == '':
		#	print 'PMIDs:', pmidsearch
		print 


	def gpr(self, filename):
		#read gpr.txt file
		print 'gpr from', filename
		file = open(filename)
		while True:
			line = file.readline()
			if line == '': break
			line = line.rstrip()
			if line == '': continue
			if line[0] == '#': continue
			#split each line into key and value; 'c' tells what kind of relationship ('rxn -> prots', etc.)
			#key is transcript, prot, or reaction; 
			#value is boolean expression of constituent components that are necessary/sufficient
			c, k, v = line.split('\t')[0], line.split('\t')[1], line.split('\t')[2]
			#parse expression 'v'
			linarr, newarr = v.split(), []
			for e in linarr:
				#e is something like "((g1" or "|" or "&" or "g2"
				#need to retain form of expression but replace all things like "g1" with "genes['g1']"
				#if encounter boolean operators, add them to newarr then continue
				if e == '&' or e == '|':
					newarr.append(e)
					continue
				#isolate "g1" from "((g1", etc.; item will hold the piece isolated from e
				item = ''
				for i in e:
					#skip parentheses
					if i == '(' or i == ')':
						continue
					item = item + i
				#now have isolated item, determine its type
				#must be a way to recognize genes: 
				#c is 'rp' for <rxn -> prot1 | prot2> or 'pg' for <prot1 -> gene1> statements
				if c[:2] == 'pg': 
					book = 'genes'
					self.GENES[item] = 1
				elif c[:2] == 'rp': 
					book = 'prots'
				#make "g1" into "genes['g1']", etc., and replace this into original expression
				newitem = book + "['" + item + "']"
				#add to newarr
				newarr.append(e.replace(item, newitem))
			#newstr is new expression that looks like: "genes['g1'] | genes['g2']", etc.	
			newstr = (' ').join(newarr)
			#determine whether key is a transcript, prot, or reaction; place new expression in dictionary
			if c[:2] == 'rp': self.REACTS[k] = newstr
			elif c[:2] == 'pg': self.PROTS[k] = newstr
		print


	def build_from_textfiles(self, modelfile, biomassfile, sourcesfile, escapesfile=None, constraintsfile=None, notesfile=None):
		#one line command to build model from text files.
		cb.build(self, modelfile)
		cb.biomass(self, biomassfile)
		cb.sources(self, sourcesfile)
		if escapesfile:
			cb.escapes(self, escapesfile)
		if constraintsfile:
			cb.constraints(self, constraintsfile)
		if notesfile:
			cb.notes(self, notesfile)


	def write_sbml (self, filename=None):
		"Write model into SBML format"
		
		m = Model(self.MODEL_ID, self.MODEL_NAME)
		
		for c in self.COMPARTMENTS:
			cdict = self.COMPARTMENTS[c]
			compid, compoutside = cdict['id'], cdict.get('outside', None)

			sbmlcomp = Compartment(str(compid))
			if compoutside:
				sbmlcomp.setOutside(str(compoutside))
			m.addCompartment(sbmlcomp)


		for s in self.SPECIES:
			sdict = self.SPECIES[s]
			specid, specname, speccharge, strbc, speccompartment = sdict['id'], sdict['name'], sdict['charge'], str(sdict['boundaryCondition']), sdict['compartment']

			#ensure that boundaryCondition is a boolean value
			specbc = ensure_boolean(specid, strbc)

			sbmlspec = Species(str(specid), str(specname))
			sbmlspec.setCompartment(str(speccompartment))
			sbmlspec.setCharge(int(speccharge))
			sbmlspec.setBoundaryCondition(specbc)
			m.addSpecies(sbmlspec)
			
		for r in self.REACTIONS:
			name, revraw, notes, [reactants, products] = self.REACTIONS[r]

			#ensure that reversibility is a boolean value
			strrev = str(revraw)
			rev = ensure_boolean(r, revraw)

			sbmlrxn = Reaction(str(r), str(name))
			sbmlrxn.setReversible(rev)
			for reactant, coef in reactants:
				reactantSpeciesReference = SpeciesReference(str(reactant), float(coef))
				sbmlrxn.addReactant(reactantSpeciesReference)
			for product, coef in products:
				productSpeciesReference = SpeciesReference(str(product), float(coef))
				sbmlrxn.addProduct(productSpeciesReference)
			
			############
			#this approach is valid, but not very elegant...
			sbmlnote = ''
			nkeys = notes.keys()
			nkeys.sort()
			for note in nkeys:
				
				#to find notes with invalid xml characters, try this...
				try:
					unote = unicode(note)
				except:
					print note
				
				node = XMLNode()
				newnode = node.convertStringToXMLNode('<html:p xmlns:html="http://www.w3.org/1999/xhtml">' + note + '</html:p>')
				sbmlrxn.appendNotes(newnode)
			############
				
			m.addReaction(sbmlrxn)

		sbmldoc = SBMLDocument()
		#this level and version necessary for working with Cytoscape (there may be others, but default lev and version don't work)
		sbmldoc.setLevelAndVersion(2,1)
		sbmldoc.setModel(m)

		writer = SBMLWriter()
		if filename:
			writer.writeSBML(sbmldoc, filename)
		else:
			writer.writeSBML(sbmldoc, self.MODEL_ID + '.sbml')
			
	
	def read_sbml(self, filename):
		"Read in an sbml file."
		reader = SBMLReader()
		sbmldoc = reader.readSBML(filename)
		model = sbmldoc.getModel()

		self.MODEL_ID, self.MODEL_NAME = model.getId(), model.getName()

		for compartment in model.getListOfCompartments():
			id, outside = compartment.getId(), compartment.getOutside()
			cdict = {'id':id, 'outside':outside}
			self.COMPARTMENTS[id] = cdict

		for species in model.getListOfSpecies():
			id, name, charge, bc, compartment = species.getId(), species.getName(), species.getCharge(), species.getBoundaryCondition(), species.getCompartment()
			sdict = {'id':id, 'name':name, 'charge':charge, 'compartment':compartment, 'boundaryCondition':bc}
			self.SPECIES[id] = sdict

		for reaction in model.getListOfReactions():
			id, name, rev = reaction.getId(), reaction.getName(), reaction.getReversible()
			eq = [[],[]]

			for reactant in reaction.getListOfReactants():
				species, coef = reactant.getSpecies(), reactant.getStoichiometry()
				eq[0].append((species, str(coef)))

			for product in reaction.getListOfProducts():
				species, coef = product.getSpecies(), product.getStoichiometry()
				eq[1].append((species, str(coef)))

			notes = {}
			if reaction.getNotes():
				notesnode = reaction.getNotes()
				numbernotes = notesnode.getNumChildren()
				for i in range(numbernotes):
					childnode = notesnode.getChild(i)
					rawnote = childnode.convertXMLNodeToString(childnode)
					note = rawnote[50:-9]
					notes[rawnote[50:-9]] = 1

			self.REACTIONS[id] = (name, rev, notes, eq)
			

	def check_charge_balance(self, equation):
		"Check whether an equation is charge balanced. Reaction must result in no net change in charges within a compartment."
		compartment_side_2_charge = {'reactants':{}, 'products':{}}
		for compartment in self.COMPARTMENTS:
			compartment_side_2_charge['reactants'][compartment] = 0
			compartment_side_2_charge['products'][compartment] = 0

		for spec, coef in equation[0]:
			species_charge = int(self.SPECIES[spec]['charge']) * float(coef)
			compartment = self.SPECIES[spec]['compartment']
			compartment_side_2_charge['reactants'][compartment] = compartment_side_2_charge['reactants'][compartment] + species_charge

		for spec, coef in equation[1]:
			species_charge = int(self.SPECIES[spec]['charge']) * float(coef)
			compartment = self.SPECIES[spec]['compartment']
			compartment_side_2_charge['products'][compartment] = compartment_side_2_charge['products'][compartment] + species_charge

		balanced = True
		
		for c in compartment_side_2_charge['reactants'].keys() + compartment_side_2_charge['products'].keys():
			if not compartment_side_2_charge['reactants'][c] == compartment_side_2_charge['products'][c]:
				balanced = False
				
		return balanced
		
		
	def report_charge_imbalances(self):
		"Report all equations that are not charge balanced."
		for r in self.REACTIONS:
			name, revraw, notes, equation = self.REACTIONS[r]
			
			#ensure rxn reversibility is boolean value
			rev = ensure_boolean(r, revraw)
			if rev:
				arrow = '<=> '
			else:
				arrow = '--> '
				
			if not cb.check_charge_balance(self, equation):
				print r, eq.makestring(equation, rev)
				strcharges = ''
				for side in equation:
					for spec, coef in side:
						strcharges = strcharges + str(float(coef)*float(self.SPECIES[spec]['charge'])) + ' '
					strcharges = strcharges + arrow
				print '\t', strcharges[:-4]
		
		
	def deletion_testing (self):
		"Probably do not need this anymore."
		essential_reactions = {}
		cb.solve(self, verbose=False)
		fullstatus, fullobjectivevalue = self.STATUS, self.OBJECTIVE_VALUE
		for r in self.REACTIONS:
			if not r == self.OBJECTIVE[1]:
				name, rev, notes, equation = self.REACTIONS[r]
				if rev:
					lbound = '-' + self.VMAX
				else:
					lbound = '0'
				default_lbound, default_ubound = self.CONSTRAINTS.get(r, (lbound, self.VMAX))
				cb.set_constraint(self, r, 0, 0)
				cb.solve(self, verbose=False)
				
				if (not self.STATUS == 'OPTIMAL') or (float(self.OBJECTIVE_VALUE) < 0.25 * float(fullobjectivevalue)):
					#reactionequation = eq.makestring(equation, rev)
					#print r + '\t' + reactionequation + '\t' + self.STATUS + '\t' + str(self.OBJECTIVE_VALUE)
					essential_reactions[r] = 1
				cb.set_constraint(self, r, default_lbound, default_ubound)
		return essential_reactions		
		
	#calculator: given vector of gene presence/absence, calculate reaction presence/absence
	def calc (self):
		#make copies of the transcr, prots, reacts dictionaries so you don't change the global ones
		genes = self.GENES.copy()
		transcr = self.TRANSCR.copy()
		for t in transcr:
			#here and below, ensure that transcr[t] (or prots[p], ...) is a string so can use eval()
			#might be an integer, if you've specified a vector for presence/absence of transcripts
			transcr[t] = str(transcr[t])
			transcr[t] = eval(transcr[t])
		prots = self.PROTS.copy()
		for p in prots:
			prots[p] = str(prots[p])
			prots[p] = eval(prots[p])
		reacts = self.REACTS.copy()
		deletedrxns = {}
		for r in reacts:
			reacts[r] = str(reacts[r])
			reacts[r] = eval(reacts[r])
			if reacts[r] == 0 and r in self.REACTIONS:
				deletedrxns[r] = 1
		return deletedrxns
				

	def deletions (self, level):
		"Delete all genes, proteins, or reactions, one at a time."
		cb.solve(self, verbose=False)
		fullstatus, fullobjectivevalue = self.STATUS, self.OBJECTIVE_VALUE
		#item is a gene, protein, or reaction; level is self.GENES, self.PROTS, or self.REACTS
		for item in level:
			#delete item
			level[item] = 0
			#calculate consequences of deleted item according to boolean rules (i.e., which reactions are eliminated?)
			deletedrxns = cb.calc(self)
			#now constrain each reaction that is deleted by the change to have zero flux, attempt fba
			for r in deletedrxns:
				name, rev, notes, equation = self.REACTIONS[r]
				if rev:
					lbound = '-' + self.VMAX
				else:
					lbound = '0'
				default_lbound, default_ubound = self.CONSTRAINTS.get(r, (lbound, self.VMAX))
				cb.set_constraint(self, r, 0, 0)
				cb.solve(self, verbose=False)
				#if status != OPTIMAL or objective value is < 25% of 'wild type', print item, reaction, and results
				if (not self.STATUS == 'OPTIMAL') or (float(self.OBJECTIVE_VALUE) < 0.25 * float(fullobjectivevalue)):
					reactionequation = eq.makestring(equation, rev)
					print item + '\t' + r + '\t' + reactionequation + '\t' + self.STATUS + '\t' + str(self.OBJECTIVE_VALUE)
				#reset reaction constraints to default	
				cb.set_constraint(self, r, default_lbound, default_ubound)
			#make item (gene, protein, ...) available again
			level[item] = 1
			

	def paul (self):
		"Algorithm to find a minimal set of source / escape reactions to convert a model with no solutions to one with a solution."
		#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		#WRITE *.dat FILE....

		datfilename = self.MODEL_ID + '.dat'
		datfile = open(datfilename, 'w')
		print >>datfile, "set REACTIONS := "
		for r in self.REACTIONS:
			print >>datfile, r,
		print >>datfile, ";\n"
		print >>datfile, "set METABOLITES := "
		for s in self.SPECIES:
			print >>datfile, s,
		print >>datfile, ";\n"
		print >>datfile, "set KNOWNSOURCES := "
		for s in self.SOURCES:
			print >>datfile, s[:-1] + 'b',
		print >>datfile, ";\n"
		print >>datfile, "set NOTSOURCES := "
		for n in self.NOTSOURCES:
			print >>datfile, n,
		print >>datfile, ";\n"
		print >>datfile, "set KNOWNESCAPES := "
		for e in self.ESCAPES:
			print >>datfile, e[:-1] + 'b',
		print >>datfile, ";\n"
		print >>datfile, "set NOTESCAPES := "
		for n in self.NOTESCAPES:
			print >>datfile, n,
		print >>datfile, ";\n"
		print >>datfile, "set BIOMASSREACTION := " + self.OBJECTIVE[1] + ";"
		print >>datfile, "\n"
		print >>datfile, "param S := "
		
		mets = {}
		constraints = {}
		for ID in self.REACTIONS:
					
			name, reversible, notes, equation = self.REACTIONS[ID]
						
			#if there have been specific constraints already set, use them...
			if ID in self.CONSTRAINTS:
				lbound, ubound = self.CONSTRAINTS[ID]
			#otherwise create constraints on the fly, using reaction reversibility and self.VMAX...
			else:
				ubound = self.VMAX
				if bool(reversible):
					lbound = '-' + self.VMAX
				else:
					lbound = '0'
			constraints[ID] = (lbound, ubound)	
				
			#create a data structure called 'mets': keys are metabolites, values are (reactionID, coef); this is essentially "S * v"
			for reactant in equation[0]:
				species, coef = reactant[0], '-' + str(reactant[1])
				#if '_b' == species[-2:]:
				#	continue
				if not species in mets:
					mets[species] = []
				mets[species].append((ID, coef))
				
			for product in equation[1]:
				species, coef = product[0], product[1]
				#if '_b' == species[-2:]:
				#	continue
				if not species in mets:
					mets[species] = []
				mets[species].append((ID, coef))

		#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

		for m in mets:
			rclist = mets[m]
			for rxn, coef in rclist:
				print >>datfile, m, rxn, coef
		print >>datfile, ";"
		print >>datfile, "param lb := "
		for r in self.REACTIONS:
			if r in constraints:
				lbound, ubound = constraints[r]
				print >>datfile, r, lbound
		print >>datfile, ";"
		print >>datfile, "param ub := "
		for r in self.REACTIONS:
			if r in constraints:
				lbound, ubound = constraints[r]
				print >>datfile, r, ubound
		print >>datfile, ";"
		print >>datfile, "param minbiomass := " + '1' + ";"
		print >>datfile, "end;\n"
		
		datfile.close()
		
		com1 = "/Users/seth/.lib/python/glpsol --tmlim 50 -m /Users/seth/.lib/python/metmodel/transport.mod -d " + datfilename + " -o transport.out"
		com2 = "rm " + datfilename
		com3 = "python /Users/seth/.lib/python/metmodel/out2transports.py transport.out" # > " + self.MODEL_ID + ".se"
		com4 = "rm transport.out"

		os.system(com1)
		os.system(com2)
		os.system(com3)
		os.system(com4)
		
		
	def drawfluxdist (self, modelmapfile, filename):
		"Draw a flux distribution onto a model map made with CellDesigner, contained in the indicated .xml file."
		if self.REACTION2FLUXVALUE == {}:
			print 'Cannot draw flux distribution...must solve model first.'
			return 0
	
		#read in underlying model map
		reader = SBMLReader()
		sbmldoc = reader.readSBML(modelmapfile)
		model = sbmldoc.getModel()
		mapreactions = model.getListOfReactions()
		
		r2f = {}			#mapping of reaction to abs value of flux
		transparent = {}	#initial set of reactions that are to be made transparent (superset of map reactions)
		for reaction in self.REACTIONS:
			fluxvalue = float(self.REACTION2FLUXVALUE.get(reaction, 0))
			revreaction = reaction + '_r'
			if fluxvalue < 0:
				#make forward reaction flux arrow transparent
				transparent[reaction] = 1
				#set reverse reaction flux = absoluteval(fluxvalue)
				revfluxvalue = abs(fluxvalue)
				r2f[revreaction] = revfluxvalue
			else:
				#set forward reaction flux to fluxvalue
				r2f[reaction] = fluxvalue
				#make reverse reaction flux arrow transparent
				transparent[revreaction] = 1

		#regular expressions to capture linewidth and color of reaction arrows
		linew_re = re.compile(r"""\"\d\.\d\"""")
		color_re = re.compile(r"""\"\w\w\w\w\w\w\w\w\"""")

		#flip thru reactions, modify annotation with arrow attributes according to flux value
		#final list of transparent reactions: those in 'transparent' and on map
		maptransparent = {}
		for reaction in mapreactions:
			id, name, rev = reaction.getId(), reaction.getName(), reaction.getReversible()
			
			#transparent reactions essentially deleted from map below
			if name in transparent:
				maptransparent[name] = id
				
			#annotation specifies reaction edge attributes
			annot = reaction.getAnnotationString()

			fluxvalue = r2f.get(name, 0)
			
			#assign attributes based on flux value
			if fluxvalue == 0:
				r, g, b, trans, thick = '00', '00', '00', '30', 1.0
			elif 0 < fluxvalue <= 2:		#low flux -> blue
				r, g, b, trans, thick = '00', '00', str(hex(255)[2:]), 'ff', 1.0
			elif 2 < fluxvalue <= 5:	#intermed -> green
				r, g, b, trans, thick = '00', str(hex(255)[2:]), '00', 'ff', 3.0		
			elif 5 < fluxvalue <= 1000:	#high flux -> red
				r, g, b, trans, thick = str(hex(255)[2:]), '00', '00', 'ff', 5.0
			else:
				print reaction, fluxvalue, 'not accounted for by drawfluxdist function'
			
			newlinew = '"' + str(thick) + '"'	
			newcolor = '"' + trans + r + g + b + '"'

			#find part of annotation with edge attributes, alter it, set new annotation
			newannotarr = []
			for line in annot.split('\n'):
				if 'celldesigner:line width=' in line:
					if linew_re.search(line):
						linew = linew_re.search(line).group()
					if color_re.search(line):
						color = color_re.search(line).group()
					#replace old linewidth and color with new
					linetmp = line.replace(linew, newlinew)
					newline = linetmp.replace(color, newcolor)
					newannotarr.append(newline)
				else:
					newannotarr.append(line)
			#set annotation to the new one you just made		
			newannot = ('\n').join(newannotarr[1:-1])
			reaction.setAnnotation(newannot)

		#delete transparent reactions from map
		for reaction in maptransparent:
			id = maptransparent[reaction]
			ListOf.remove(mapreactions, id)

		#write out a new sbml file containing the altered map	
		writer = SBMLWriter()	
		writer.writeSBML(sbmldoc, filename)
		
		
	def ddeletions (self):
		"Double deletions at the reaction level."
		cb.solve(self, verbose=False)
		essential_reactions = cb.deletion_testing(self)

		fullstatus, fullobjectivevalue = self.STATUS, self.OBJECTIVE_VALUE
		for i, r in enumerate(self.REACTIONS.keys()):
			if not r == self.OBJECTIVE[1] and not r in essential_reactions and not 'R_ESC' in r and not 'R_SRC' in r:
				name, rev, notes, equation = self.REACTIONS[r]
				if rev:
					lbound = '-' + self.VMAX
				else:
					lbound = '0'
				default_lbound, default_ubound = self.CONSTRAINTS.get(r, (lbound, self.VMAX))
				cb.set_constraint(self, r, 0, 0)
				
				for j, r2 in enumerate(self.REACTIONS.keys()[i+1:]):
					if not r2 == self.OBJECTIVE[1] and not r2 in essential_reactions and not 'R_ESC' in r2 and not 'R_SRC' in r2:
						name2, rev2, notes2, equation2 = self.REACTIONS[r2]
						if rev2:
							lbound2 = '-' + self.VMAX
						else:
							lbound2 = '0'
						default_lbound2, default_ubound2 = self.CONSTRAINTS.get(r2, (lbound2, self.VMAX))
						cb.set_constraint(self, r2, 0, 0)
				
						cb.solve(self, verbose=False)
						
						if (not self.STATUS == 'OPTIMAL') or (float(self.OBJECTIVE_VALUE) < 0.25 * float(fullobjectivevalue)):
							reactionequation1 = eq.makestring(equation, rev)
							reactionequation2 = eq.makestring(equation2, rev2)
							print self.STATUS + '\t' + str(self.OBJECTIVE_VALUE)
							print r + '\t' + reactionequation1
							print r2 + '\t' + reactionequation2
							print
						cb.set_constraint(self, r2, default_lbound2, default_ubound2)
						
				cb.set_constraint(self, r, default_lbound, default_ubound)	

